{"version":3,"sources":["webpack://PhotoPassport/webpack/universalModuleDefinition","webpack://PhotoPassport/webpack/bootstrap","webpack://PhotoPassport/../src/constants.js","webpack://PhotoPassport/../src/options.js","webpack://PhotoPassport/../src/create-element.js","webpack://PhotoPassport/../src/component.js","webpack://PhotoPassport/../src/render.js","webpack://PhotoPassport/../src/create-context.js","webpack://PhotoPassport/../src/util.js","webpack://PhotoPassport/../src/diff/children.js","webpack://PhotoPassport/../src/diff/props.js","webpack://PhotoPassport/../src/diff/index.js","webpack://PhotoPassport/../src/clone-element.js","webpack://PhotoPassport/../src/diff/catch-error.js","webpack://PhotoPassport/./node_modules/axios/lib/utils.js","webpack://PhotoPassport/../src/index.js","webpack://PhotoPassport/../src/PureComponent.js","webpack://PhotoPassport/../src/memo.js","webpack://PhotoPassport/../src/forwardRef.js","webpack://PhotoPassport/../src/Children.js","webpack://PhotoPassport/../src/suspense.js","webpack://PhotoPassport/../src/suspense-list.js","webpack://PhotoPassport/../src/portals.js","webpack://PhotoPassport/./node_modules/eventemitter3/index.js","webpack://PhotoPassport/./node_modules/axios/index.js","webpack://PhotoPassport/_header.js","webpack://PhotoPassport/packages/@interactjs/utils/isWindow.ts","webpack://PhotoPassport/packages/@interactjs/utils/window.ts","webpack://PhotoPassport/packages/@interactjs/utils/is.ts","webpack://PhotoPassport/packages/@interactjs/actions/drag/plugin.ts","webpack://PhotoPassport/packages/@interactjs/utils/domObjects.ts","webpack://PhotoPassport/packages/@interactjs/utils/browser.ts","webpack://PhotoPassport/packages/@interactjs/utils/domUtils.ts","webpack://PhotoPassport/packages/@interactjs/utils/extend.ts","webpack://PhotoPassport/packages/@interactjs/utils/rect.ts","webpack://PhotoPassport/packages/@interactjs/utils/getOriginXY.ts","webpack://PhotoPassport/packages/@interactjs/utils/normalizeListeners.ts","webpack://PhotoPassport/packages/@interactjs/utils/hypot.ts","webpack://PhotoPassport/packages/@interactjs/utils/pointerExtend.ts","webpack://PhotoPassport/packages/@interactjs/utils/pointerUtils.ts","webpack://PhotoPassport/packages/@interactjs/core/BaseEvent.ts","webpack://PhotoPassport/packages/@interactjs/utils/arr.ts","webpack://PhotoPassport/packages/@interactjs/actions/drop/DropEvent.ts","webpack://PhotoPassport/packages/@interactjs/actions/drop/plugin.ts","webpack://PhotoPassport/packages/@interactjs/actions/gesture/plugin.ts","webpack://PhotoPassport/packages/@interactjs/actions/resize/plugin.ts","webpack://PhotoPassport/packages/@interactjs/actions/plugin.ts","webpack://PhotoPassport/packages/@interactjs/arrange/plugin.ts","webpack://PhotoPassport/packages/@interactjs/utils/raf.ts","webpack://PhotoPassport/packages/@interactjs/auto-scroll/plugin.ts","webpack://PhotoPassport/packages/@interactjs/utils/misc.ts","webpack://PhotoPassport/packages/@interactjs/auto-start/InteractableMethods.ts","webpack://PhotoPassport/packages/@interactjs/auto-start/base.ts","webpack://PhotoPassport/packages/@interactjs/auto-start/dragAxis.ts","webpack://PhotoPassport/packages/@interactjs/auto-start/hold.ts","webpack://PhotoPassport/packages/@interactjs/auto-start/plugin.ts","webpack://PhotoPassport/packages/@interactjs/clone/plugin.ts","webpack://PhotoPassport/packages/@interactjs/core/interactablePreventDefault.ts","webpack://PhotoPassport/packages/@interactjs/dev-tools/plugin.ts","webpack://PhotoPassport/packages/@interactjs/utils/clone.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/Modification.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/base.ts","webpack://PhotoPassport/packages/@interactjs/core/defaultOptions.ts","webpack://PhotoPassport/packages/@interactjs/core/InteractEvent.ts","webpack://PhotoPassport/packages/@interactjs/core/PointerInfo.ts","webpack://PhotoPassport/packages/@interactjs/core/Interaction.ts","webpack://PhotoPassport/packages/@interactjs/offset/plugin.ts","webpack://PhotoPassport/packages/@interactjs/inertia/plugin.ts","webpack://PhotoPassport/packages/@interactjs/core/Eventable.ts","webpack://PhotoPassport/packages/@interactjs/core/isNonNativeEvent.ts","webpack://PhotoPassport/packages/@interactjs/core/Interactable.ts","webpack://PhotoPassport/packages/@interactjs/core/InteractableSet.ts","webpack://PhotoPassport/packages/@interactjs/core/events.ts","webpack://PhotoPassport/packages/@interactjs/core/interactStatic.ts","webpack://PhotoPassport/packages/@interactjs/core/interactionFinder.ts","webpack://PhotoPassport/packages/@interactjs/core/interactions.ts","webpack://PhotoPassport/packages/@interactjs/core/scope.ts","webpack://PhotoPassport/packages/@interactjs/interact/index.ts","webpack://PhotoPassport/packages/@interactjs/snappers/edgeTarget.ts","webpack://PhotoPassport/packages/@interactjs/snappers/elements.ts","webpack://PhotoPassport/packages/@interactjs/snappers/grid.ts","webpack://PhotoPassport/packages/@interactjs/snappers/plugin.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/aspectRatio.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/noop.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/restrict/pointer.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/restrict/edges.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/restrict/rect.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/restrict/size.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/snap/pointer.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/snap/size.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/snap/edges.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/all.ts","webpack://PhotoPassport/packages/@interactjs/modifiers/plugin.ts","webpack://PhotoPassport/packages/@interactjs/pointer-events/PointerEvent.ts","webpack://PhotoPassport/packages/@interactjs/pointer-events/base.ts","webpack://PhotoPassport/packages/@interactjs/pointer-events/holdRepeat.ts","webpack://PhotoPassport/packages/@interactjs/pointer-events/interactableTargets.ts","webpack://PhotoPassport/packages/@interactjs/pointer-events/plugin.ts","webpack://PhotoPassport/packages/@interactjs/reflow/plugin.ts","webpack://PhotoPassport/packages/@interactjs/utils/displace.ts","webpack://PhotoPassport/packages/@interactjs/utils/exchange.ts","webpack://PhotoPassport/packages/@interactjs/interactjs/index.ts","webpack://PhotoPassport/packages/interactjs/index.ts","webpack://PhotoPassport/node_modules/browser-pack-flat/_postlude","webpack://PhotoPassport/./node_modules/axios/lib/helpers/bind.js","webpack://PhotoPassport/./node_modules/axios/lib/helpers/buildURL.js","webpack://PhotoPassport/./node_modules/axios/lib/cancel/isCancel.js","webpack://PhotoPassport/./node_modules/axios/lib/defaults.js","webpack://PhotoPassport/./node_modules/axios/lib/adapters/xhr.js","webpack://PhotoPassport/./node_modules/axios/lib/core/createError.js","webpack://PhotoPassport/./node_modules/axios/lib/core/mergeConfig.js","webpack://PhotoPassport/./node_modules/axios/lib/cancel/Cancel.js","webpack://PhotoPassport/./node_modules/react-loadingmask/dist/react-loadingmask.js","webpack://PhotoPassport/./node_modules/react-loadingmask/dist/react-loadingmask.css?a6d6","webpack://PhotoPassport/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://PhotoPassport/./node_modules/react-loadingmask/dist/react-loadingmask.css","webpack://PhotoPassport/./node_modules/css-loader/dist/runtime/api.js","webpack://PhotoPassport/./node_modules/axios/lib/axios.js","webpack://PhotoPassport/./node_modules/axios/lib/core/Axios.js","webpack://PhotoPassport/./node_modules/axios/lib/core/InterceptorManager.js","webpack://PhotoPassport/./node_modules/axios/lib/core/dispatchRequest.js","webpack://PhotoPassport/./node_modules/axios/lib/core/transformData.js","webpack://PhotoPassport/./node_modules/process/browser.js","webpack://PhotoPassport/./node_modules/axios/lib/helpers/normalizeHeaderName.js","webpack://PhotoPassport/./node_modules/axios/lib/core/settle.js","webpack://PhotoPassport/./node_modules/axios/lib/core/enhanceError.js","webpack://PhotoPassport/./node_modules/axios/lib/helpers/cookies.js","webpack://PhotoPassport/./node_modules/axios/lib/core/buildFullPath.js","webpack://PhotoPassport/./node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack://PhotoPassport/./node_modules/axios/lib/helpers/combineURLs.js","webpack://PhotoPassport/./node_modules/axios/lib/helpers/parseHeaders.js","webpack://PhotoPassport/./node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack://PhotoPassport/./node_modules/axios/lib/cancel/CancelToken.js","webpack://PhotoPassport/./node_modules/axios/lib/helpers/spread.js","webpack://PhotoPassport/./src/style/styles.scss","webpack://PhotoPassport/./src/model/point.js","webpack://PhotoPassport/./src/model/photodimensions.js","webpack://PhotoPassport/./src/shared/event-emitter/events.js","webpack://PhotoPassport/./src/components/editor/index.js","webpack://PhotoPassport/./src/components/preview/index.js","webpack://PhotoPassport/./src/components/app.js","webpack://PhotoPassport/./src/index.js"],"names":["options","isValidElement","rerenderQueue","defer","prevDebounce","IS_HYDRATE","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","push","defaultProps","undefined","createVNode","original","vnode","constructor","createRef","current","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","newDom","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","placeChild","value","unmount","applyRef","toChildArray","out","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","diffProps","dom","newProps","oldProps","hydrate","setProperty","setStyle","style","test","name","oldValue","useCapture","nameLower","proxy","cssText","replace","toLowerCase","slice","_listeners","eventProxyCapture","eventProxy","addEventListener","removeEventListener","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","e","event","reorderChildren","newVNode","tmp","isNew","oldState","snapshot","clearProcessingException","provider","componentContext","newType","contextType","prototype","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","call","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","checked","parentVNode","skipRemove","r","componentWillUnmount","this","replaceNode","cloneElement","createContext","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","error","ctor","handled","wasHydrating","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout","currentIndex","currentComponent","prevRaf","currentHook","afterPaintEffects","oldBeforeRender","oldAfterDiff","oldCommit","oldBeforeUnmount","getHookState","index","hooks","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","action","nextValue","useEffect","args","argsChanged","useLayoutEffect","useRef","initialValue","useMemo","useImperativeHandle","createHandle","concat","factory","useCallback","useContext","useDebugValue","formatter","useErrorBoundary","errState","err","flushAfterPaintEffects","forEach","invokeCleanup","invokeEffect","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","filter","hook","_cleanup","oldArgs","newArgs","arg","f","shallowDiffers","PureComponent","p","memo","comparer","shouldUpdate","nextProps","updateRef","Memoed","displayName","isReactComponent","isPureReactComponent","oldDiffHook","REACT_FORWARD_SYMBOL","Symbol","for","forwardRef","fn","Forwarded","clone","$$typeof","mapFn","map","Children","count","only","normalized","toArray","oldCatchError","detachedClone","removeOriginal","Suspense","_suspenders","suspended","lazy","loader","prom","Lazy","exports","default","SuspenseList","_next","_map","promise","suspendingComponent","resolved","onResolved","onSuspensionComplete","pop","fallback","list","delete","revealOrder","size","ContextProvider","Portal","_this","container","_container","wrap","parent","_temp","_unmount","_wrap","_hasMounted","createPortal","delegated","get","unsuspend","wrappedUnsuspend","Map","reverse","set","REACT_ELEMENT_TYPE","CAMEL_PROPS","ONCHANGE_INPUT_TYPES","textContent","preactRender","preactHydrate","Object","defineProperty","configurable","v","writable","oldEventHook","empty","isPropagationStopped","cancelBubble","isDefaultPrevented","defaultPrevented","persist","nativeEvent","classNameDescriptor","class","oldVNodeHook","enumerable","className","multiple","selected","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","readContext","version","createFactory","element","preactCloneElement","apply","unmountComponentAtNode","findDOMNode","unstable_batchedUpdates","StrictMode","pt","Math","dx","dy","x","pt1","pt2","p1","ratio","dist","p0","pa","pb","p2","ddx","ddy","m","d","p1s","pointsAtDistanceNorm","p2s","w2","width","h2","height","cosAngle","sinAngle","corners","center","y","middlePoint","crownToBottom","crownToCenter","mmToPixRatio","crownPoint","crownToCenterPix","pointAtDistance","centerPic","getCroppingCenter","faceHeightPix","normal","scale","cropHeightPix","cropWidthPix","rotatedRectangle","Events","UPDATE_LANDMARK","LOADED_IMAGE","url","response","blob","reader","crownPosition","chinPosition","landmarkVisibility","image","console","prevProps","lmSize","standard","interact","inertia","modifiers","restriction","endOnly","elementRect","top","left","bottom","right","onmove","target","parseFloat","onend","viewPortWidth","viewPortHeight","_viewPortHeight","xRatio","yRatio","xw","yh","chinPoint","parseInt","imageHeight","imageWidth","round","xPrime","yPrime","elmt","faceHeight","crownSegment","chinSegment","ra","rb","pc","angleRad","angleDeg","cropCenter","svgElmt","points","invalidCrop","ptPix","w","h","angle","svdElmt","visibility","preview","cropArea","axios","previewSize","display","view","imageUrl","defaults"],"mappings":"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AEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C,2BAA2B;AAC3B;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4BAA4B;AAC5B,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3VA,IAAI+L,eAGAC,eAcAC,eAXAC,eAAc,EAGdC,eAAoB,GAEpBC,EAAkB1M,qCAClB2M,EAAe3M,iCAAQiJ,OACvB2D,eAAY5M,qCACZ6M,EAAmB7M,iCAAQgF,QAkE/B,SAAS8H,EAAaC,EAAO7L,GACxBlB,sCACHA,qCAAcsM,eAAkBS,EAAOP,gBAAetL,GAEvDsL,eAAc,MAORQ,EACLV,qBACCA,mBAA2B,IACpB,OACU,YAGfS,GAASC,KAAYxL,QACxBwL,KAAYvL,KAAK,IAEXuL,KAAYD,GAMb,SAASE,EAASC,UACxBV,eAAc,EACPW,EAAWC,EAAgBF,GASnC,SAAgBC,EAAWE,EAASH,EAAcI,OAE3CC,EAAYT,EAAaT,iBAAgB,UAC/CkB,EAAUC,EAAWH,EAChBE,QACJA,MAAuB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IAAvBU,EAAUkG,UAAkBlG,IACjD,KAYF,IAAMuT,GAA0B,SAAC/K,EAAUgE,UAAQhE,EAASgE,IAMtDgH,GAAa3U,kCAgCJ,oFACd+K,WACAE,aACAQ,YACAG,kBACAC,QAACA,CACDG,sBACAD,UACAK,cACAC,aACAC,gBACA6H,QAlHe,SAmHf/E,WACAnJ,SACArC,UACA4Q,0BACA1C,eACA/S,qDACAyJ,qDACA4L,iBACA7L,gBACAzI,6CACAE,2CACAjC,kBACA0W,eACAxU,6CACA6N,gBACAE,qBACAa,aACA6F,2BACAC,WA9DkB3U,kCA+DlB4P,yBACAS,eACAN,qBACAiE;;;;;;;;AQ5KY;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yDAAyD,OAAO;AAChE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,eAAe,YAAY;AAC3B;;AAEA;AACA,2DAA2D;AAC3D,+DAA+D;AAC/D,mEAAmE;AACnE,uEAAuE;AACvE;AACA,0DAA0D,SAAS;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,IAA6B;AACjC;AACA;;;;;;;AC/UA,iBAAiB,mBAAO,CAAC,EAAa,E;;;;;;;ACAtC,CAMA,gE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ACvB,UCNF,ODSC,WAAD,QAA4B,WCV5B;;;;;;;;ACAa;;AAEb;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;;;;;;;ACVa;;AAEb,YAAY,mBAAO,CAAC,CAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACrEa;;AAEb;AACA;AACA;;;;;;;;ACJA,+CAAa;;AAEb,YAAY,mBAAO,CAAC,CAAS;AAC7B,0BAA0B,mBAAO,CAAC,EAA+B;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,EAAgB;AACtC,GAAG;AACH;AACA,cAAc,mBAAO,CAAC,EAAiB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO,YAAY;AACnB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;;;;;;;;;ACjGa;;AAEb,YAAY,mBAAO,CAAC,CAAY;AAChC,aAAa,mBAAO,CAAC,EAAkB;AACvC,cAAc,mBAAO,CAAC,EAAsB;AAC5C,eAAe,mBAAO,CAAC,CAAuB;AAC9C,oBAAoB,mBAAO,CAAC,EAAuB;AACnD,mBAAmB,mBAAO,CAAC,EAA2B;AACtD,sBAAsB,mBAAO,CAAC,EAA8B;AAC5D,kBAAkB,mBAAO,CAAC,EAAqB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;;;;;;ACzLa;;AAEb,mBAAmB,mBAAO,CAAC,EAAgB;;AAE3C;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;;;;;;;ACjBa;;AAEb,YAAY,mBAAO,CAAC,CAAU;;AAE9B;AACA;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CA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;;;;;;;;AC7Fa;;AAEb,YAAY,mBAAO,CAAC,CAAY;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;ACnDa;;AAEb,YAAY,mBAAO,CAAC,CAAY;AAChC,oBAAoB,mBAAO,CAAC,EAAiB;AAC7C,eAAe,mBAAO,CAAC,CAAoB;AAC3C,eAAe,mBAAO,CAAC,CAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;AC9Ea;;AAEb,YAAY,mBAAO,CAAC,CAAY;;AAEhC;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,MAAM;AACjB,WAAW,eAAe;AAC1B,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;ACnBA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;ACvLzB;;AAEb,YAAY,mBAAO,CAAC,CAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;ACXa;;AAEb,kBAAkB,mBAAO,CAAC,EAAe;;AAEzC;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxBa;;AAEb;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCa;;AAEb,YAAY,mBAAO,CAAC,CAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C;AAC1C,SAAS;;AAET;AACA,4DAA4D,wBAAwB;AACpF;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,kCAAkC;AAClC,+BAA+B,aAAa,EAAE;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;ACpDa;;AAEb,oBAAoB,mBAAO,CAAC,EAA0B;AACtD,kBAAkB,mBAAO,CAAC,EAAwB;;AAElD;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnBa;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACba;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,CAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;ACpDa;;AAEb,YAAY,mBAAO,CAAC,CAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;ACnEa;;AAEb,aAAa,mBAAO,CAAC,EAAU;;AAE/B;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1Be,gEAAuB,eAAe,E;;;;;;;;;;;;;;;;;;;;;;ACA9C,SAAP;AAECnU,iBAAW,CAAXA,EAAW,CAAXA,EAAkB;AAAA;;AACjB;AACA;AACA;;AALF;AA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","file":"bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhotoPassport\"] = factory();\n\telse\n\t\troot[\"PhotoPassport\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n","export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import options from './options';\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\t_hydrating: null,\n\t\tconstructor: undefined,\n\t\t_original: original\n\t};\n\n\tif (original == null) vnode._original = vnode;\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = oldVNode;\n\n\t\tlet newDom = diff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tvnode._hydrating != null ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom,\n\t\t\tvnode._hydrating\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (newDom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\nconst CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\n\n// Input types for which onchange should not be converted to oninput.\n// type=\"file|checkbox|radio\", plus \"range\" in IE11.\n// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches \"range\")\nconst ONCHANGE_INPUT_TYPES =\n\ttypeof Symbol != 'undefined' ? /fil|che|rad/i : /fil|che|ra/i;\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n[\n\t'componentWillMount',\n\t'componentWillReceiveProps',\n\t'componentWillUpdate'\n].forEach(key => {\n\tObject.defineProperty(Component.prototype, key, {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this['UNSAFE_' + key];\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: v\n\t\t\t});\n\t\t}\n\t});\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\te.persist = empty;\n\te.isPropagationStopped = isPropagationStopped;\n\te.isDefaultPrevented = isDefaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\nfunction empty() {}\n\nfunction isPropagationStopped() {\n\treturn this.cancelBubble;\n}\n\nfunction isDefaultPrevented() {\n\treturn this.defaultPrevented;\n}\n\nlet classNameDescriptor = {\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tlet type = vnode.type;\n\tlet props = vnode.props;\n\n\tconst isComponent = typeof type == 'function';\n\tif (isComponent) {\n\t\tif ((classNameDescriptor.enumerable = 'className' in props)) {\n\t\t\tprops.class = props.className;\n\t\t}\n\t\tObject.defineProperty(props, 'className', classNameDescriptor);\n\t} else if (type) {\n\t\tlet normalizedProps = {};\n\n\t\tfor (let i in props) {\n\t\t\tlet value = props[i];\n\n\t\t\t// Alias `class` prop to `className` if available\n\t\t\tif (i === 'className') {\n\t\t\t\tnormalizedProps.class = value;\n\t\t\t\tclassNameDescriptor.enumerable = true;\n\t\t\t}\n\n\t\t\tif (i === 'defaultValue' && 'value' in props && props.value == null) {\n\t\t\t\t// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.\n\t\t\t\t// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.\n\t\t\t\ti = 'value';\n\t\t\t} else if (i === 'download' && value === true) {\n\t\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t\t// value will be used as the file name and the file will be called\n\t\t\t\t// \"true\" upon downloading it.\n\t\t\t\tvalue = '';\n\t\t\t} else if (/ondoubleclick/i.test(i)) {\n\t\t\t\ti = 'ondblclick';\n\t\t\t} else if (\n\t\t\t\t/^onchange(textarea|input)/i.test(i + type) &&\n\t\t\t\t!ONCHANGE_INPUT_TYPES.test(props.type)\n\t\t\t) {\n\t\t\t\ti = 'oninput';\n\t\t\t} else if (/^on(Ani|Tra|Tou|BeforeInp)/.test(i)) {\n\t\t\t\ti = i.toLowerCase();\n\t\t\t} else if (CAMEL_PROPS.test(i)) {\n\t\t\t\ti = i.replace(/[A-Z0-9]/, '-$&').toLowerCase();\n\t\t\t} else if (value === null) {\n\t\t\t\tvalue = undefined;\n\t\t\t}\n\n\t\t\tnormalizedProps[i] = value;\n\t\t}\n\n\t\tObject.defineProperty(normalizedProps, 'className', classNameDescriptor);\n\n\t\t// Add support for array select values: <select multiple value={[]} />\n\t\tif (\n\t\t\ttype == 'select' &&\n\t\t\tnormalizedProps.multiple &&\n\t\t\tArray.isArray(normalizedProps.value)\n\t\t) {\n\t\t\t// forEach() always returns undefined, which we abuse here to unset the value prop.\n\t\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.value.indexOf(child.props.value) != -1;\n\t\t\t});\n\t\t}\n\n\t\tvnode.props = normalizedProps;\n\t}\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function(vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection. So far\n// only `react-relay` makes use of it. It uses it to read the\n// context value.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t}\n\t\t}\n\t}\n};\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\tProvider(props, subs, ctx) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tsubs = [];\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../index').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Node | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\t// Only in very specific places should this logic be invoked (top level `render` and `diffElementNodes`).\n\t// I'm using `EMPTY_OBJ` to signal when `diffChildren` is invoked in these situations. I can't use `null`\n\t// for this purpose, because `null` is a valid value for `oldDom` which can mean to skip to this logic\n\t// (e.g. if mounting a new tree in which the old DOM should be ignored (usually for Fragments).\n\tif (oldDom == EMPTY_OBJ) {\n\t\tif (excessDomChildren != null) {\n\t\t\toldDom = excessDomChildren[0];\n\t\t} else if (oldChildrenLength) {\n\t\t\toldDom = getDomSibling(oldParentVNode, 0);\n\t\t} else {\n\t\t\toldDom = null;\n\t\t}\n\t}\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._dom != null || childVNode._component != null) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\toldDom = placeChild(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\toldVNode,\n\t\t\t\toldChildren,\n\t\t\t\texcessDomChildren,\n\t\t\t\tnewDom,\n\t\t\t\toldDom\n\t\t\t);\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type == 'option') {\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove children that are not part of any vnode.\n\tif (excessDomChildren != null && typeof newParentVNode.type != 'function') {\n\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) unmount(oldChildren[i], oldChildren[i]);\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nexport function placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\texcessDomChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\texcessDomChildren == oldVNode ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t// The values only have the same type when `null`.\n\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture, nameLower, proxy;\n\n\tif (isSvg && name == 'className') name = 'class';\n\n\t// if (isSvg) {\n\t// \tif (name === 'className') name = 'class';\n\t// } else if (name === 'class') name += 'Name';\n\n\tif (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tnameLower = name.toLowerCase();\n\t\tif (nameLower in dom) name = nameLower;\n\t\tname = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tproxy = useCapture ? eventProxyCapture : eventProxy;\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, proxy, useCapture);\n\t\t} else {\n\t\t\tdom.removeEventListener(name, proxy, useCapture);\n\t\t}\n\t} else if (\n\t\tname !== 'list' &&\n\t\tname !== 'tagName' &&\n\t\t// HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using\n\t\t// setAttribute\n\t\tname !== 'form' &&\n\t\tname !== 'type' &&\n\t\tname !== 'size' &&\n\t\tname !== 'download' &&\n\t\tname !== 'href' &&\n\t\t!isSvg &&\n\t\tname in dom\n\t) {\n\t\tdom[name] = value == null ? '' : value;\n\t} else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {\n\t\tif (name !== (name = name.replace(/xlink:?/, ''))) {\n\t\t\tif (value == null || value === false) {\n\t\t\t\tdom.removeAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom.setAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase(),\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\tvalue == null ||\n\t\t\t(value === false &&\n\t\t\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t\t\t// The value `false` is different from the attribute not\n\t\t\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t\t\t// that other VDOM frameworks also always stringify `false`.\n\t\t\t\t!/^ar/.test(name))\n\t\t) {\n\t\t\tdom.removeAttribute(name);\n\t\t} else {\n\t\t\tdom.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Component } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren, placeChild } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode } from '../util';\nimport options from '../options';\n\nfunction reorderChildren(newVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < newVNode._children.length; tmp++) {\n\t\tconst vnode = newVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\tvnode._parent = newVNode;\n\n\t\t\tif (vnode._dom) {\n\t\t\t\tif (typeof vnode.type == 'function' && vnode._children.length > 1) {\n\t\t\t\t\treorderChildren(vnode, oldDom, parentDom);\n\t\t\t\t}\n\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tnewVNode._children,\n\t\t\t\t\tnull,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\n\t\t\t\tif (typeof newVNode.type == 'function') {\n\t\t\t\t\tnewVNode._nextDom = oldDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Element | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._hydrating != null) {\n\t\tisHydrating = oldVNode._hydrating;\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\t// if we resume, we want the tree to be \"unlocked\"\n\t\tnewVNode._hydrating = null;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\treorderChildren(newVNode, oldDom, parentDom);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type == Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._hydrating = null;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\tnewVNode._dom = oldDom;\n\t\t\tnewVNode._hydrating = !!isHydrating;\n\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t// ^ could possibly be simplified to:\n\t\t\t// excessDomChildren.length = 0;\n\t\t}\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n\n\treturn newVNode._dom;\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet i;\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type === 'svg' || isSvg;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild != null &&\n\t\t\t\t((newVNode.type === null\n\t\t\t\t\t? child.nodeType === 3\n\t\t\t\t\t: child.localName === newVNode.type) ||\n\t\t\t\t\tdom == child)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (newVNode.type === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = isSvg\n\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type)\n\t\t\t: document.createElement(\n\t\t\t\t\tnewVNode.type,\n\t\t\t\t\tnewProps.is && { is: newProps.is }\n\t\t\t  );\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (newVNode.type === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\tif (excessDomChildren != null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (let i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (\n\t\t\t\t\t!newHtml ||\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\n\t\t\t\t) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnewVNode.type === 'foreignObject' ? false : isSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tEMPTY_OBJ,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(i !== dom.value || (newVNode.type === 'progress' && !i))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tlet dom;\n\tif (!skipRemove && typeof vnode.type != 'function') {\n\t\tskipRemove = (dom = vnode._dom) != null;\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) unmount(r[i], parentVNode, skipRemove);\n\t\t}\n\t}\n\n\tif (dom != null) removeNode(dom);\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { assign } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n","// import { enqueueRender } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, ctor, handled;\n\n\tconst wasHydrating = vnode._hydrating;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\tvnode._hydrating = wasHydrating;\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","'use strict';\n\nvar bind = require('./helpers/bind');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n","import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '16.8.0'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p) {\n\tthis.props = p;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function(props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionalComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function forwardRef(fn) {\n\t// We always have ref in props.ref, except for\n\t// mobx-react. It will call this function directly\n\t// and always pass ref as the second argument.\n\tfunction Forwarded(props, ref) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\tref = props.ref || ref;\n\t\treturn fn(\n\t\t\tclone,\n\t\t\t!ref || (typeof ref === 'object' && !('current' in ref)) ? null : ref\n\t\t);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function(error, newVNode, oldVNode) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode._component);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode);\n};\n\nfunction detachedClone(vnode) {\n\tif (vnode) {\n\t\tvnode = assign({}, vnode);\n\t\tvnode._component = null;\n\t\tvnode._children = vnode._children && vnode._children.map(detachedClone);\n\t}\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode) {\n\tif (vnode) {\n\t\tvnode._original = null;\n\t\tvnode._children = vnode._children && vnode._children.map(removeOriginal);\n\t}\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @param {Promise} promise The thrown promise\n * @param {Component<any, any>} suspendingComponent The suspending component\n */\nSuspense.prototype._childDidSuspend = function(promise, suspendingComponent) {\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent.componentWillUnmount =\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._suspendedComponentWillUnmount =\n\t\tsuspendingComponent.componentWillUnmount;\n\tsuspendingComponent.componentWillUnmount = () => {\n\t\tonResolved();\n\n\t\tif (suspendingComponent._suspendedComponentWillUnmount) {\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount();\n\t\t}\n\t};\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\tc._vnode._children[0] = removeOriginal(c.state._suspended);\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * We do not set `suspended: true` during hydration because we want the actual markup\n\t * to remain on screen and hydrate it when the suspense actually gets resolved.\n\t * While in non-hydration cases the usual fallback -> component flow would occour.\n\t */\n\tconst vnode = c._vnode;\n\tconst wasHydrating = vnode && vnode._hydrating === true;\n\tif (!wasHydrating && !c._pendingSuspensionCount++) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function() {\n\tthis._suspenders = [];\n};\n\nSuspense.prototype.render = function(props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children)\n\t\t\tthis._vnode._children[0] = detachedClone(this._detachOnNextRender);\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\t// Wrap fallback tree in a VNode that prevents itself from being marked as aborting mid-hydration:\n\tconst fallback =\n\t\tstate._suspended && createElement(Fragment, null, props.fallback);\n\tif (fallback) fallback._hydrating = null;\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tfallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('../src/internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function(child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function(props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function() {\n\t// Iterate through all children after mounting for two reasons:\n\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t//    The nodes can now be completely consumed from the linked list.\n\t// 2. Handle nodes that might have gotten resolved between render and\n\t//    componentDidMount.\n\tthis._map.forEach((node, child) => {\n\t\tresolve(this, child, node);\n\t});\n};\n","import { createElement, hydrate, render, __u as _unmount } from 'preact';\n\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @param {object | null | undefined} props\n *\n * TODO: this could use the \"fake root node\" trick from the partial hydration demo\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\tlet wrap = createElement(\n\t\tContextProvider,\n\t\t{ context: _this.context },\n\t\tprops._vnode\n\t);\n\n\t_this.componentWillUnmount = function() {\n\t\tlet parent = _this._temp.parentNode;\n\t\tif (parent) parent.removeChild(_this._temp);\n\t\t_unmount(_this._wrap);\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t\t_this._hasMounted = false;\n\t}\n\n\t// When props.vnode is undefined/false/null we are dealing with some kind of\n\t// conditional vnode. This should not trigger a render.\n\tif (props._vnode) {\n\t\tif (!_this._hasMounted) {\n\t\t\t// Create a placeholder that we can use to insert into.\n\t\t\t_this._temp = document.createTextNode('');\n\t\t\t// temporarily store the current children of the container to restore them after render\n\t\t\t_this._children = container._children;\n\t\t\t// Hydrate existing nodes to keep the dom intact, when rendering\n\t\t\t// wrap into the container.\n\t\t\thydrate('', container);\n\t\t\t// Append to the container (this matches React's behavior)\n\t\t\tcontainer.appendChild(_this._temp);\n\t\t\t// At this point we have mounted and should set our container.\n\t\t\t_this._hasMounted = true;\n\t\t\t_this._container = container;\n\t\t\t// Render our wrapping element into temp.\n\t\t\trender(wrap, container, _this._temp);\n\t\t\t// restore the previous children of the container\n\t\t\tcontainer._children = _this._children;\n\t\t\t// store the children of the new vnode to be used in subsequent re-renders\n\t\t\t_this._children = _this._temp._children;\n\t\t} else {\n\t\t\t// When we have mounted and the vnode is present it means the\n\t\t\t// props have changed or a parent is triggering a rerender.\n\t\t\t// This implies we only need to call render. But we need to keep\n\t\t\t// the old tree around, otherwise will treat the vnodes as new and\n\t\t\t// will wrongly call `componentDidMount` on them\n\t\t\tcontainer._children = _this._children;\n\t\t\trender(wrap, container);\n\t\t\t_this._children = container._children;\n\t\t}\n\t}\n\t// When we come from a conditional render, on a mounted\n\t// portal we should clear the DOM.\n\telse if (_this._hasMounted) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t}\n\t// Set the wrapping element for future unmounting.\n\t_this._wrap = wrap;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\treturn createElement(Portal, { _vnode: vnode, _container: container });\n}\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","module.exports = require('./lib/axios');","/**\n * interact.js 1.9.22\n *\n * Copyright (c) 2012-present Taye Adeyemi <dev@taye.me>\n * Released under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n","export default (thing: any) => !!(thing && thing.Window) && (thing instanceof thing.Window)\n","import isWindow from './isWindow'\n\nexport let realWindow = undefined as Window\n\nlet win = undefined as Window\nexport { win as window }\n\nexport function init (window: Window & { wrap?: (...args: any[]) => any }) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  realWindow = window\n\n  // create a TextNode\n  const el = window.document.createTextNode('')\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document &&\n      typeof window.wrap === 'function' &&\n    window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window)\n  }\n\n  win = window\n}\n\nif (typeof window !== 'undefined' && !!window) {\n  init(window)\n}\n\nexport function getWindow (node: any) {\n  if (isWindow(node)) {\n    return node\n  }\n\n  const rootNode = (node.ownerDocument || node)\n\n  return rootNode.defaultView || win.window\n}\n","import * as Interact from '@interactjs/types/index'\n\nimport isWindow from './isWindow'\nimport * as win from './window'\n\nconst window = (thing: any): thing is Window =>\n  thing === win.window || isWindow(thing)\n\nconst docFrag = (thing: any): thing is DocumentFragment =>\n  object(thing) && thing.nodeType === 11\n\nconst object = (thing: any): thing is { [index: string]: any } =>\n  !!thing && (typeof thing === 'object')\n\nconst func = (thing: any): thing is (...args: any[]) => any =>\n  typeof thing === 'function'\n\nconst number = (thing: any): thing is number =>\n  typeof thing === 'number'\n\nconst bool = (thing: any): thing is boolean =>\n  typeof thing === 'boolean'\n\nconst string = (thing: any): thing is string =>\n  typeof thing === 'string'\n\nconst element = (thing: any): thing is Interact.Element => {\n  if (!thing || (typeof thing !== 'object')) { return false }\n\n  // eslint-disable-next-line import/no-named-as-default-member\n  const _window = win.getWindow(thing) || win.window\n\n  return (/object|function/.test(typeof _window.Element)\n    ? thing instanceof _window.Element // DOM2\n    : thing.nodeType === 1 && typeof thing.nodeName === 'string')\n}\n\nconst plainObject: typeof object = (thing: any): thing is { [index: string]: any } =>\n  object(thing) &&\n  !!thing.constructor &&\n  /function Object\\b/.test(thing.constructor.toString())\n\nconst array = <T extends unknown>(thing: any): thing is T[] =>\n  (object(thing) &&\n  (typeof thing.length !== 'undefined') &&\n  func(thing.splice))\n\nexport default {\n  window,\n  docFrag,\n  object,\n  func,\n  number,\n  bool,\n  string,\n  element,\n  plainObject,\n  array,\n}\n","import { Scope } from '@interactjs/core/scope'\nimport * as Interact from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    draggable: DraggableMethod\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    drag: Interact.DraggableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drag?: typeof drag\n  }\n}\n\nexport type DragEvent = Interact.InteractEvent<'drag'>\n\nexport type DraggableMethod = Interact.ActionMethod<Interact.DraggableOptions>\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    Interactable,\n    defaults,\n  } = scope\n\n  Interactable.prototype.draggable = drag.draggable\n\n  actions.map.drag = drag\n  actions.methodDict.drag = 'draggable'\n\n  defaults.actions.drag = drag.defaults\n}\n\nfunction beforeMove ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') { return }\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x') {\n    interaction.coords.cur.page.y   = interaction.coords.start.page.y\n    interaction.coords.cur.client.y = interaction.coords.start.client.y\n\n    interaction.coords.velocity.client.y = 0\n    interaction.coords.velocity.page.y   = 0\n  }\n  else if (axis === 'y') {\n    interaction.coords.cur.page.x   = interaction.coords.start.page.x\n    interaction.coords.cur.client.x = interaction.coords.start.client.x\n\n    interaction.coords.velocity.client.x = 0\n    interaction.coords.velocity.page.x   = 0\n  }\n}\n\nfunction move ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'drag') { return }\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x' || axis === 'y') {\n    const opposite = axis === 'x' ? 'y' : 'x'\n\n    iEvent.page[opposite]   = interaction.coords.start.page[opposite]\n    iEvent.client[opposite] = interaction.coords.start.client[opposite]\n    iEvent.delta[opposite] = 0\n  }\n}\n\n/**\n * ```js\n * interact(element).draggable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // the axis in which the first movement must be\n *     // for the drag sequence to start\n *     // 'xy' by default - any direction\n *     startAxis: 'x' || 'y' || 'xy',\n *\n *     // 'xy' by default - don't restrict to one axis (move in any direction)\n *     // 'x' or 'y' to restrict movement to either axis\n *     // 'start' to restrict movement to the axis the drag started in\n *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n *\n *     // max number of drags that can happen concurrently\n *     // with elements of this Interactable. Infinity by default\n *     max: Infinity,\n *\n *     // max number of drags that can target the same element+Interactable\n *     // 1 by default\n *     maxPerElement: 2\n * })\n *\n * var isDraggable = interact('element').draggable(); // true\n * ```\n *\n * Get or set whether drag actions can be performed on the target\n *\n * @alias Interactable.prototype.draggable\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on drag events (object makes the Interactable\n * draggable)\n * @return {boolean | Interactable} boolean indicating if this can be the\n * target of drag events, or this Interctable\n */\nconst draggable: DraggableMethod = function draggable (this: Interact.Interactable, options?: Interact.DraggableOptions | boolean): any {\n  if (is.object(options)) {\n    this.options.drag.enabled = options.enabled !== false\n    this.setPerAction('drag', options)\n    this.setOnEvents('drag', options)\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis\n    }\n\n    return this\n  }\n\n  if (is.bool(options)) {\n    this.options.drag.enabled = options\n\n    return this\n  }\n\n  return this.options.drag\n}\n\nconst drag: Interact.Plugin = {\n  id: 'actions/drag',\n  install,\n  listeners: {\n    'interactions:before-action-move': beforeMove,\n    'interactions:action-resume': beforeMove,\n\n    // dragmove\n    'interactions:action-move': move,\n    'auto-start:check': arg => {\n      const { interaction, interactable, buttons } = arg\n      const dragOptions = interactable.options.drag\n\n      if (\n        !(dragOptions && dragOptions.enabled) ||\n        // check mouseButton setting if the pointer is down\n        (interaction.pointerIsDown &&\n         /mouse|pointer/.test(interaction.pointerType) &&\n       (buttons & interactable.options.drag.mouseButtons) === 0)\n      ) {\n        return undefined\n      }\n\n      arg.action = {\n        name: 'drag',\n        axis: (dragOptions.lockAxis === 'start'\n          ? dragOptions.startAxis\n          : dragOptions.lockAxis),\n      }\n\n      return false\n    },\n  },\n  draggable,\n  beforeMove,\n  move,\n  defaults: {\n    startAxis : 'xy',\n    lockAxis  : 'xy',\n  } as Interact.DropzoneOptions,\n\n  getCursor () {\n    return 'move'\n  },\n}\n\nexport default drag\n","const domObjects: {\n  init: any\n  document: Document\n  DocumentFragment: typeof DocumentFragment\n  SVGElement: typeof SVGElement\n  SVGSVGElement: typeof SVGSVGElement\n  SVGElementInstance: any\n  Element: typeof Element\n  HTMLElement: typeof HTMLElement\n  Event: typeof Event\n  Touch: typeof Touch\n  PointerEvent: typeof PointerEvent\n} =\n{\n  init,\n  document: null,\n  DocumentFragment: null,\n  SVGElement: null,\n  SVGSVGElement: null,\n  SVGElementInstance: null,\n  Element: null,\n  HTMLElement: null,\n  Event: null,\n  Touch: null,\n  PointerEvent: null,\n}\n\nfunction blank () {}\n\nexport default domObjects\n\nfunction init (window: Window) {\n  const win = window as any\n\n  domObjects.document           = win.document\n  domObjects.DocumentFragment   = win.DocumentFragment   || blank\n  domObjects.SVGElement         = win.SVGElement         || blank\n  domObjects.SVGSVGElement      = win.SVGSVGElement      || blank\n  domObjects.SVGElementInstance = win.SVGElementInstance || blank\n  domObjects.Element            = win.Element            || blank\n  domObjects.HTMLElement        = win.HTMLElement        || domObjects.Element\n\n  domObjects.Event        = win.Event\n  domObjects.Touch        = win.Touch || blank\n  domObjects.PointerEvent = (win.PointerEvent || win.MSPointerEvent)\n}\n","import domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nconst browser = {\n  init,\n  supportsTouch: null as boolean,\n  supportsPointerEvent: null as boolean,\n  isIOS7: null as boolean,\n  isIOS: null as boolean,\n  isIe9: null as boolean,\n  isOperaMobile: null as boolean,\n  prefixedMatchesSelector: null as 'matches',\n  pEventTypes: null as {\n    up: string\n    down: string\n    over: string\n    out: string\n    move: string\n    cancel: string\n  },\n  wheelEvent: null as string,\n}\n\nfunction init (window: any) {\n  const Element = domObjects.Element\n  const navigator  = win.window.navigator\n\n  // Does the browser support touch input?\n  browser.supportsTouch = ('ontouchstart' in window) ||\n    (is.func(window.DocumentTouch) && domObjects.document instanceof window.DocumentTouch)\n\n  // Does the browser support PointerEvents\n  browser.supportsPointerEvent = navigator.pointerEnabled !== false && !!domObjects.PointerEvent\n\n  browser.isIOS = (/iP(hone|od|ad)/.test(navigator.platform))\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  browser.isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform) &&\n           /OS 7[^\\d]/.test(navigator.appVersion))\n\n  browser.isIe9 = /MSIE 9/.test(navigator.userAgent)\n\n  // Opera Mobile must be handled differently\n  browser.isOperaMobile = (navigator.appName === 'Opera' &&\n    browser.supportsTouch &&\n    /Presto/.test(navigator.userAgent))\n\n  // prefix matchesSelector\n  browser.prefixedMatchesSelector = ('matches' in Element.prototype\n    ? 'matches'\n    : 'webkitMatchesSelector' in Element.prototype\n      ? 'webkitMatchesSelector'\n      : 'mozMatchesSelector' in Element.prototype\n        ? 'mozMatchesSelector'\n        : 'oMatchesSelector' in Element.prototype\n          ? 'oMatchesSelector'\n          : 'msMatchesSelector') as 'matches'\n\n  browser.pEventTypes = (browser.supportsPointerEvent\n    ? (domObjects.PointerEvent === window.MSPointerEvent\n      ? {\n        up:     'MSPointerUp',\n        down:   'MSPointerDown',\n        over:   'mouseover',\n        out:    'mouseout',\n        move:   'MSPointerMove',\n        cancel: 'MSPointerCancel',\n      }\n      : {\n        up:     'pointerup',\n        down:   'pointerdown',\n        over:   'pointerover',\n        out:    'pointerout',\n        move:   'pointermove',\n        cancel: 'pointercancel',\n      })\n    : null)\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  browser.wheelEvent = 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n}\n\nexport default browser\n","import * as Interact from '@interactjs/types/index'\n\nimport browser from './browser'\nimport domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nexport function nodeContains (parent: Node, child: Node) {\n  if (parent.contains) {\n    return parent.contains(child as Node)\n  }\n\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest (element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) { return element }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode (node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector (element: Interact.Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = (el: Node | Document | ShadowRoot) => el.parentNode || (el as ShadowRoot).host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement (elements: Interact.Element[] | NodeListOf<Element>) {\n  let deepestNodeParents: Node[] = []\n  let deepestNodeIndex: number\n\n  for (let i = 0; i < elements.length; i++) {\n    const currentNode = elements[i]\n    const deepestNode: Node = elements[deepestNodeIndex]\n\n    // node may appear in elements array multiple times\n    if (!currentNode || i === deepestNodeIndex) {\n      continue\n    }\n\n    if (!deepestNode) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    const currentNodeParent = getParent(currentNode)\n    const deepestNodeParent = getParent(deepestNode)\n\n    // check if the deepest or current are document.documentElement/rootElement\n    // - if the current node is, do nothing and continue\n    if (currentNodeParent === currentNode.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current node and continue to next\n    else if (deepestNodeParent === currentNode.ownerDocument) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (currentNodeParent === deepestNodeParent) {\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\n        deepestNodeIndex = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest node\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\n\n    let ancestryStart: Node\n\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\n    if (deepestNode instanceof domObjects.HTMLElement &&\n      currentNode instanceof domObjects.SVGElement &&\n      !(currentNode instanceof domObjects.SVGSVGElement)\n    ) {\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\n      if (currentNode === deepestNodeParent) {\n        continue\n      }\n\n      ancestryStart = currentNode.ownerSVGElement\n    }\n    else {\n      ancestryStart = currentNode\n    }\n\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\n    let commonIndex = 0\n\n    // get (position of closest common ancestor) + 1\n    while (currentNodeParents[commonIndex] && currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]) {\n      commonIndex++\n    }\n\n    const parents = [\n      currentNodeParents[commonIndex - 1],\n      currentNodeParents[commonIndex],\n      deepestNodeParents[commonIndex],\n    ]\n\n    let child = parents[0].lastChild\n\n    while (child) {\n      if (child === parents[1]) {\n        deepestNodeIndex = i\n        deepestNodeParents = currentNodeParents\n\n        break\n      }\n      else if (child === parents[2]) {\n        break\n      }\n\n      child = child.previousSibling\n    }\n  }\n\n  return deepestNodeIndex\n}\n\nfunction getNodeParents (node: Node, limit?: Node) {\n  const parents: Node[] = []\n  let parent: Node = node\n  let parentParent: Node\n\n  while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {\n    parents.unshift(parent)\n    parent = parentParent\n  }\n\n  return parents\n}\n\nfunction zIndexIsHigherThan (higherNode: Node, lowerNode: Node) {\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\n\n  return higherIndex >= lowerIndex\n}\n\nexport function matchesUpTo (element: Interact.Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Interact.Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement (element: Interact.Element) {\n  return (element as SVGElement).correspondingUseElement || element\n}\n\nexport function getScrollXY (relevantWindow?: Window) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect (element: Interact.Element): Required<Interact.Rect> {\n  const clientRect = (element instanceof domObjects.SVGElement\n    ? element.getBoundingClientRect()\n    : element.getClientRects()[0])\n\n  return clientRect && {\n    left  : clientRect.left,\n    right : clientRect.right,\n    top   : clientRect.top,\n    bottom: clientRect.bottom,\n    width : clientRect.width  || clientRect.right  - clientRect.left,\n    height: clientRect.height || clientRect.bottom - clientRect.top,\n  }\n}\n\nexport function getElementRect (element: Interact.Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left   += scroll.x\n    clientRect.right  += scroll.x\n    clientRect.top    += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath (node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector (value: Interact.Target) {\n  if (!is.string(value)) { return false }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n","export default function extend<T, U extends object> (dest: U & Partial<T>, source: T): T & U {\n  for (const prop in source) {\n    (dest as unknown as T)[prop] = source[prop]\n  }\n\n  const ret = dest as T & U\n\n  return ret\n}\n","import * as Interact from '@interactjs/types/index'\n\nimport { closest, getElementRect, parentNode } from './domUtils'\nimport extend from './extend'\nimport is from './is'\n\nexport function getStringOptionResult (value: any, target: Interact.HasGetRect, element: Node) {\n  if (value === 'parent') { return parentNode(element) }\n\n  if (value === 'self') { return target.getRect(element as Interact.Element) }\n\n  return closest(element, value)\n}\n\nexport function resolveRectLike<T extends any[]> (\n  value: Interact.RectResolvable<T>,\n  target?: Interact.HasGetRect,\n  element?: Node,\n  functionArgs?: T,\n) {\n  let returnValue: any = value\n  if (is.string(returnValue)) {\n    returnValue = getStringOptionResult(returnValue, target, element)\n  }\n  else if (is.func(returnValue)) {\n    returnValue = returnValue(...functionArgs)\n  }\n\n  if (is.element(returnValue)) {\n    returnValue = getElementRect(returnValue)\n  }\n\n  return returnValue as Interact.Rect\n}\n\nexport function rectToXY (rect: Interact.Rect | Interact.Point) {\n  return  rect && {\n    x: 'x' in rect ? rect.x : rect.left,\n    y: 'y' in rect ? rect.y : rect.top,\n  }\n}\n\nexport function xywhToTlbr<T extends Partial<Interact.Rect & Interact.Point>> (rect: T) {\n  if (rect && !('left' in rect && 'top' in rect)) {\n    rect = extend({}, rect)\n\n    rect.left   = rect.x || 0\n    rect.top    = rect.y || 0\n    rect.right  = rect.right   || (rect.left + rect.width)\n    rect.bottom = rect.bottom  || (rect.top + rect.height)\n  }\n\n  return rect as Interact.Rect & T\n}\n\nexport function tlbrToXywh (rect: Interact.Rect & Partial<Interact.Point>) {\n  if (rect && !('x' in rect && 'y' in rect)) {\n    rect = extend({}, rect)\n\n    rect.x      = rect.left || 0\n    rect.y      = rect.top  || 0\n    rect.width  = rect.width  || ((rect.right || 0)  - rect.x)\n    rect.height = rect.height || ((rect.bottom || 0) - rect.y)\n  }\n\n  return rect as Interact.FullRect & Interact.Point\n}\n\nexport function addEdges (edges: Interact.EdgeOptions, rect: Interact.Rect, delta: Interact.Point) {\n  if (edges.left)   { rect.left   += delta.x }\n  if (edges.right)  { rect.right  += delta.x }\n  if (edges.top)    { rect.top    += delta.y }\n  if (edges.bottom) { rect.bottom += delta.y }\n\n  rect.width = rect.right - rect.left\n  rect.height = rect.bottom - rect.top\n}\n","import * as Interact from '@interactjs/types/index'\n\nimport { rectToXY, resolveRectLike } from './rect'\n\nexport default function (\n  target: Interact.HasGetRect & { options: Interact.PerActionDefaults },\n  element: Node,\n  actionName?: Interact.ActionName,\n) {\n  const actionOptions = (target.options as any)[actionName]\n  const actionOrigin = actionOptions && actionOptions.origin\n  const origin = actionOrigin || target.options.origin\n\n  const originRect = resolveRectLike(origin, target, element, [target && element])\n\n  return rectToXY(originRect) || { x: 0, y: 0 }\n}\n","import * as Interact from '@interactjs/types/index'\n\nimport extend from './extend'\nimport is from './is'\n\nexport interface NormalizedListeners {\n  [type: string]: Interact.Listener[]\n}\n\nexport default function normalize (\n  type: Interact.EventTypes,\n  listeners?: Interact.ListenersArg | Interact.ListenersArg[],\n  result?: NormalizedListeners,\n): NormalizedListeners {\n  result = result || {}\n\n  if (is.string(type) && type.search(' ') !== -1) {\n    type = split(type)\n  }\n\n  if (is.array(type)) {\n    return type.reduce<NormalizedListeners>(\n      (acc, t) => extend(acc, normalize(t, listeners, result)),\n      result,\n    )\n  }\n\n  // ({ type: fn }) -> ('', { type: fn })\n  if (is.object(type)) {\n    listeners = type\n    type = ''\n  }\n\n  if (is.func(listeners)) {\n    result[type] = result[type] || []\n    result[type].push(listeners)\n  }\n  else if (is.array(listeners)) {\n    for (const l of listeners) {\n      normalize(type, l, result)\n    }\n  }\n  else if (is.object(listeners)) {\n    for (const prefix in listeners) {\n      const combinedTypes = split(prefix).map(p => `${type}${p}`)\n\n      normalize(combinedTypes, listeners[prefix], result)\n    }\n  }\n\n  return result as NormalizedListeners\n}\n\nfunction split (type: string) {\n  return type.trim().split(/ +/)\n}\n","export default (x: number, y: number) =>  Math.sqrt(x * x + y * y)\n","function pointerExtend<T> (dest: Partial<T>, source: T) {\n  for (const prop in source) {\n    const prefixedPropREs = pointerExtend.prefixedPropREs\n    let deprecated = false\n\n    // skip deprecated prefixed properties\n    for (const vendor in prefixedPropREs) {\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n        deprecated = true\n        break\n      }\n    }\n\n    if (!deprecated && typeof source[prop] !== 'function') {\n      dest[prop] = source[prop]\n    }\n  }\n  return dest\n}\n\npointerExtend.prefixedPropREs = {\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n  moz: /(Pressure)$/,\n} as { [prefix: string]: RegExp }\n\nexport default pointerExtend\n","import * as Interact from '@interactjs/types/index'\n\nimport browser from './browser'\nimport dom from './domObjects'\nimport * as domUtils from './domUtils'\nimport hypot from './hypot'\nimport is from './is'\nimport pointerExtend from './pointerExtend'\n\nexport function copyCoords (dest: Interact.CoordsSetMember, src: Interact.CoordsSetMember) {\n  dest.page = dest.page || {} as any\n  dest.page.x = src.page.x\n  dest.page.y = src.page.y\n\n  dest.client = dest.client || {} as any\n  dest.client.x = src.client.x\n  dest.client.y = src.client.y\n\n  dest.timeStamp = src.timeStamp\n}\n\nexport function setCoordDeltas (targetObj: Interact.CoordsSetMember, prev: Interact.CoordsSetMember, cur: Interact.CoordsSetMember) {\n  targetObj.page.x    = cur.page.x    - prev.page.x\n  targetObj.page.y    = cur.page.y    - prev.page.y\n  targetObj.client.x  = cur.client.x  - prev.client.x\n  targetObj.client.y  = cur.client.y  - prev.client.y\n  targetObj.timeStamp = cur.timeStamp - prev.timeStamp\n}\n\nexport function setCoordVelocity (targetObj: Interact.CoordsSetMember, delta: Interact.CoordsSetMember) {\n  const dt = Math.max(delta.timeStamp / 1000, 0.001)\n\n  targetObj.page.x   = delta.page.x / dt\n  targetObj.page.y   = delta.page.y / dt\n  targetObj.client.x = delta.client.x / dt\n  targetObj.client.y = delta.client.y / dt\n  targetObj.timeStamp = dt\n}\n\nexport function setZeroCoords (targetObj: Interact.CoordsSetMember) {\n  targetObj.page.x = 0\n  targetObj.page.y = 0\n  targetObj.client.x = 0\n  targetObj.client.y = 0\n}\n\nexport function isNativePointer  (pointer: any) {\n  return (pointer instanceof dom.Event || pointer instanceof dom.Touch)\n}\n\n// Get specified X/Y coords for mouse or event.touches[0]\nexport function getXY (type: string, pointer: Interact.PointerType | Interact.InteractEvent, xy: Interact.Point) {\n  xy = xy || {} as Interact.Point\n  type = type || 'page'\n\n  xy.x = pointer[type + 'X' as keyof Interact.PointerType]\n  xy.y = pointer[type + 'Y' as keyof Interact.PointerType]\n\n  return xy\n}\n\nexport function getPageXY (pointer: Interact.PointerType | Interact.InteractEvent, page?: Interact.Point) {\n  page = page || { x: 0, y: 0 }\n\n  // Opera Mobile handles the viewport and scrolling oddly\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    getXY('screen', pointer, page)\n\n    page.x += window.scrollX\n    page.y += window.scrollY\n  }\n  else {\n    getXY('page', pointer, page)\n  }\n\n  return page\n}\n\nexport function getClientXY (pointer: Interact.PointerType, client: Interact.Point) {\n  client = client || {} as any\n\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    // Opera Mobile handles the viewport and scrolling oddly\n    getXY('screen', pointer, client)\n  }\n  else {\n    getXY('client', pointer, client)\n  }\n\n  return client\n}\n\nexport function getPointerId (pointer: { pointerId?: number, identifier?: number, type?: string }) {\n  return is.number(pointer.pointerId) ? pointer.pointerId : pointer.identifier\n}\n\nexport function setCoords (dest: Interact.CoordsSetMember, pointers: any[], timeStamp: number) {\n  const pointer = (pointers.length > 1\n    ? pointerAverage(pointers)\n    : pointers[0])\n\n  getPageXY(pointer, dest.page)\n  getClientXY(pointer, dest.client)\n\n  dest.timeStamp = timeStamp\n}\n\nexport function getTouchPair (event: TouchEvent | Interact.PointerType[]) {\n  const touches: Interact.PointerType[] = []\n\n  // array of touches is supplied\n  if (is.array(event)) {\n    touches[0] = event[0]\n    touches[1] = event[1]\n  }\n  // an event\n  else {\n    if (event.type === 'touchend') {\n      if (event.touches.length === 1) {\n        touches[0] = event.touches[0]\n        touches[1] = event.changedTouches[0]\n      }\n      else if (event.touches.length === 0) {\n        touches[0] = event.changedTouches[0]\n        touches[1] = event.changedTouches[1]\n      }\n    }\n    else {\n      touches[0] = event.touches[0]\n      touches[1] = event.touches[1]\n    }\n  }\n\n  return touches\n}\n\nexport function pointerAverage (pointers: Interact.PointerType[]) {\n  const average = {\n    pageX  : 0,\n    pageY  : 0,\n    clientX: 0,\n    clientY: 0,\n    screenX: 0,\n    screenY: 0,\n  }\n\n  type CoordKeys = keyof typeof average\n\n  for (const pointer of pointers) {\n    for (const prop in average) {\n      average[prop as CoordKeys] += pointer[prop as CoordKeys]\n    }\n  }\n  for (const prop in average) {\n    average[prop as CoordKeys] /= pointers.length\n  }\n\n  return average\n}\n\nexport function touchBBox (event: Interact.PointerType[]) {\n  if (!event.length) {\n    return null\n  }\n\n  const touches = getTouchPair(event)\n  const minX = Math.min(touches[0].pageX, touches[1].pageX)\n  const minY = Math.min(touches[0].pageY, touches[1].pageY)\n  const maxX = Math.max(touches[0].pageX, touches[1].pageX)\n  const maxY = Math.max(touches[0].pageY, touches[1].pageY)\n\n  return {\n    x: minX,\n    y: minY,\n    left: minX,\n    top: minY,\n    right: maxX,\n    bottom: maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}\n\nexport function touchDistance (event: Interact.PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = deltaSource + 'X' as 'pageX'\n  const sourceY = deltaSource + 'Y' as 'pageY'\n  const touches = getTouchPair(event)\n\n  const dx = touches[0][sourceX] - touches[1][sourceX]\n  const dy = touches[0][sourceY] - touches[1][sourceY]\n\n  return hypot(dx, dy)\n}\n\nexport function touchAngle (event: Interact.PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = deltaSource + 'X' as 'pageX'\n  const sourceY = deltaSource + 'Y' as 'pageY'\n  const touches = getTouchPair(event)\n  const dx = touches[1][sourceX] - touches[0][sourceX]\n  const dy = touches[1][sourceY] - touches[0][sourceY]\n  const angle = 180 * Math.atan2(dy, dx) / Math.PI\n\n  return  angle\n}\n\nexport function getPointerType (pointer: { pointerType?: string, identifier?: number, type?: string }) {\n  return is.string(pointer.pointerType)\n    ? pointer.pointerType\n    : is.number(pointer.pointerType)\n      ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]\n      // if the PointerEvent API isn't available, then the \"pointer\" must\n      // be either a MouseEvent, TouchEvent, or Touch object\n      : /touch/.test(pointer.type) || pointer instanceof dom.Touch\n        ? 'touch'\n        : 'mouse'\n}\n\n// [ event.target, event.currentTarget ]\nexport function getEventTargets (event: Event) {\n  const path = is.func(event.composedPath)\n    ? event.composedPath() as Interact.Element[]\n    : (event as unknown as { path: Interact.Element[]}).path\n\n  return [\n    domUtils.getActualElement(path ? path[0] : event.target as Interact.Element),\n    domUtils.getActualElement(event.currentTarget as Interact.Element),\n  ]\n}\n\nexport function newCoords (): Interact.CoordsSetMember {\n  return {\n    page     : { x: 0, y: 0 },\n    client   : { x: 0, y: 0 },\n    timeStamp: 0,\n  }\n}\n\nexport function coordsToEvent (coords: MockCoords) {\n  const event = {\n    coords,\n    get page () { return this.coords.page },\n    get client () { return this.coords.client },\n    get timeStamp () { return this.coords.timeStamp },\n    get pageX () { return this.coords.page.x },\n    get pageY () { return this.coords.page.y },\n    get clientX () { return this.coords.client.x },\n    get clientY () { return this.coords.client.y },\n    get pointerId () { return this.coords.pointerId },\n    get target () { return this.coords.target },\n    get type () { return this.coords.type },\n    get pointerType () { return this.coords.pointerType },\n    get buttons () { return this.coords.buttons },\n    preventDefault () {},\n  }\n\n  return event as typeof event & Interact.PointerType & Interact.PointerEventType\n}\n\nexport interface MockCoords {\n  page: Interact.Point\n  client: Interact.Point\n  timeStamp?: number\n  pointerId?: any\n  target?: any\n  type?: string\n  pointerType?: string\n  buttons?: number\n}\n\nexport { pointerExtend }\n","import * as Interact from '@interactjs/types/index'\n\nexport class BaseEvent<T extends Interact.ActionName = any> {\n  type: string\n  target: EventTarget\n  currentTarget: Node\n  interactable: Interact.Interactable\n  _interaction: Interact.Interaction<T>\n  timeStamp: any\n  immediatePropagationStopped = false\n  propagationStopped = false\n\n  constructor (interaction: Interact.Interaction) {\n    this._interaction = interaction\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface BaseEvent<T extends Interact.ActionName = any> {\n  interaction: Interact.InteractionProxy<T>\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperty(BaseEvent.prototype, 'interaction', {\n  get (this: BaseEvent) { return this._interaction._proxy },\n  set (this: BaseEvent) {},\n})\n","type Filter<T> = (element: T, index: number, array: T[]) => boolean\n\nexport const contains = <T>(array: T[], target: T) => array.indexOf(target) !== -1\n\nexport const remove = <T>(array: T[], target: T) => array.splice(array.indexOf(target), 1)\n\nexport const merge = <T, U>(target: Array<T | U>, source: U[]) => {\n  for (const item of source) {\n    target.push(item)\n  }\n\n  return target\n}\n\nexport const from = <T = any>(source: ArrayLike<T>) => merge([] as T[], source as T[])\n\nexport const findIndex = <T>(array: T[], func: Filter<T>) => {\n  for (let i = 0; i < array.length; i++) {\n    if (func(array[i], i, array)) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nexport const find = <T = any>(array: T[], func: Filter<T>) => array[findIndex(array, func)]\n","import { BaseEvent } from '@interactjs/core/BaseEvent'\nimport { InteractEvent } from '@interactjs/core/InteractEvent'\nimport { Interactable } from '@interactjs/core/Interactable'\nimport * as Interact from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\n\nexport class DropEvent extends BaseEvent {\n  target: Interact.Element\n  dropzone: Interactable\n  dragEvent: InteractEvent<'drag'>\n  relatedTarget: Interact.Element\n  draggable: Interactable\n  timeStamp: number\n  propagationStopped = false\n  immediatePropagationStopped = false\n\n  /**\n   * Class of events fired on dropzones during drags with acceptable targets.\n   */\n  constructor (dropState: import('./plugin').DropState, dragEvent: InteractEvent<'drag'>, type: string) {\n    super(dragEvent._interaction)\n\n    const { element, dropzone } = type === 'dragleave'\n      ? dropState.prev\n      : dropState.cur\n\n    this.type          = type\n    this.target        = element\n    this.currentTarget = element\n    this.dropzone      = dropzone\n    this.dragEvent     = dragEvent\n    this.relatedTarget = dragEvent.target\n    this.draggable     = dragEvent.interactable\n    this.timeStamp     = dragEvent.timeStamp\n  }\n\n  /**\n   * If this is a `dropactivate` event, the dropzone element will be\n   * deactivated.\n   *\n   * If this is a `dragmove` or `dragenter`, a `dragleave` will be fired on the\n   * dropzone element and more.\n   */\n  reject () {\n    const { dropState } = this._interaction\n\n    if (\n      (this.type !== 'dropactivate') && (\n        !this.dropzone ||\n        dropState.cur.dropzone !== this.dropzone ||\n        dropState.cur.element !== this.target)) {\n      return\n    }\n\n    dropState.prev.dropzone = this.dropzone\n    dropState.prev.element = this.target\n\n    dropState.rejected = true\n    dropState.events.enter = null\n\n    this.stopImmediatePropagation()\n\n    if (this.type === 'dropactivate') {\n      const activeDrops = dropState.activeDrops\n      const index = arr.findIndex(activeDrops, ({ dropzone, element }) =>\n        dropzone === this.dropzone && element === this.target)\n\n      dropState.activeDrops.splice(index, 1)\n\n      const deactivateEvent = new DropEvent(dropState, this.dragEvent, 'dropdeactivate')\n\n      deactivateEvent.dropzone = this.dropzone\n      deactivateEvent.target = this.target\n\n      this.dropzone.fire(deactivateEvent)\n    }\n    else {\n      this.dropzone.fire(new DropEvent(dropState, this.dragEvent, 'dragleave'))\n    }\n  }\n\n  preventDefault () {}\n\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n","import { InteractEvent } from '@interactjs/core/InteractEvent'\nimport { Interactable } from '@interactjs/core/Interactable'\nimport * as Interact from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport drag from '../drag/plugin'\n\nimport { DropEvent } from './DropEvent'\n\nexport interface DropzoneMethod {\n  (this: Interactable, options: Interact.DropzoneOptions | boolean): Interact.Interactable\n  (): Interact.DropzoneOptions\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    dropzone: DropzoneMethod\n    dropCheck: (\n      dragEvent: InteractEvent,\n      event: Interact.PointerEventType,\n      draggable: Interactable,\n      draggableElement: Interact.Element,\n      dropElemen: Interact.Element,\n      rect: any\n    ) => boolean\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    dropState?: DropState\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    drop: Interact.DropzoneOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    drop?: typeof drop\n  }\n\n  interface Scope {\n    dynamicDrop?: boolean\n  }\n\n  interface SignalArgs {\n    'actions/drop:start': DropSignalArg\n    'actions/drop:move': DropSignalArg\n    'actions/drop:end': DropSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/interactStatic' {\n  export interface InteractStatic {\n    dynamicDrop: (this: Interact.InteractStatic, newValue?: boolean) => boolean | this\n  }\n}\n\ninterface DropSignalArg {\n  interaction: Interact.Interaction\n  dragEvent: Interact.DragEvent\n}\n\nexport interface ActiveDrop {\n  dropzone: Interactable\n  element: Interact.Element\n  rect: Interact.Rect\n}\n\nexport interface DropState {\n  cur: {\n    dropzone: Interactable    // the dropzone a drag target might be dropped into\n    element: Interact.Element // the element at the time of checking\n  }\n  prev: {\n    dropzone: Interactable    // the dropzone that was recently dragged away from\n    element: Interact.Element // the element at the time of checking\n  }\n  rejected: boolean           // wheather the potential drop was rejected from a listener\n  events: any                 // the drop events related to the current drag event\n  activeDrops: ActiveDrop[]\n}\n\nfunction install (scope: Interact.Scope) {\n  const {\n    actions,\n    /** @lends module:interact */\n    interactStatic: interact,\n    /** @lends Interactable */\n    Interactable, // eslint-disable-line no-shadow\n    defaults,\n  } = scope\n\n  scope.usePlugin(drag)\n\n  /**\n   *\n   * ```js\n   * interact('.drop').dropzone({\n   *   accept: '.can-drop' || document.getElementById('single-drop'),\n   *   overlap: 'pointer' || 'center' || zeroToOne\n   * }\n   * ```\n   *\n   * Returns or sets whether draggables can be dropped onto this target to\n   * trigger drop events\n   *\n   * Dropzones can receive the following events:\n   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n   *  - `dragmove` when a draggable that has entered the dropzone is moved\n   *  - `drop` when a draggable is dropped into this dropzone\n   *\n   * Use the `accept` option to allow only elements that match the given CSS\n   * selector or element. The value can be:\n   *\n   *  - **an Element** - only that element can be dropped into this dropzone.\n   *  - **a string**, - the element being dragged must match it as a CSS selector.\n   *  - **`null`** - accept options is cleared - it accepts any element.\n   *\n   * Use the `overlap` option to set how drops are checked for. The allowed\n   * values are:\n   *\n   *   - `'pointer'`, the pointer must be over the dropzone (default)\n   *   - `'center'`, the draggable element's center must be over the dropzone\n   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n   *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n   *   over the dropzone\n   *\n   * Use the `checker` option to specify a function to check if a dragged element\n   * is over this Interactable.\n   *\n   * @param {boolean | object | null} [options] The new options to be set.\n   * @return {object | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.dropzone = function (this: Interact.Interactable, options?: Interact.DropzoneOptions | boolean) {\n    return dropzoneMethod(this, options)\n  } as Interactable['dropzone']\n\n  /**\n   * ```js\n   * interact(target)\n   * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n   *                       event,             // TouchEvent/PointerEvent/MouseEvent\n   *                       dropped,           // bool result of the default checker\n   *                       dropzone,          // dropzone Interactable\n   *                       dropElement,       // dropzone elemnt\n   *                       draggable,         // draggable Interactable\n   *                       draggableElement) {// draggable element\n   *\n   *   return dropped && event.target.hasAttribute('allow-drop')\n   * }\n   * ```\n   */\n  Interactable.prototype.dropCheck = function (this: Interact.Interactable, dragEvent, event, draggable, draggableElement, dropElement, rect) {\n    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)\n  }\n\n  /**\n   * Returns or sets whether the dimensions of dropzone elements are calculated\n   * on every dragmove or only on dragstart for the default dropChecker\n   *\n   * @param {boolean} [newValue] True to check on each move. False to check only\n   * before start\n   * @return {boolean | interact} The current setting or interact\n   */\n  interact.dynamicDrop = function (newValue?: boolean) {\n    if (is.bool(newValue)) {\n      // if (dragging && scope.dynamicDrop !== newValue && !newValue) {\n      //  calcRects(dropzones)\n      // }\n\n      scope.dynamicDrop = newValue\n\n      return interact\n    }\n    return scope.dynamicDrop\n  }\n\n  extend(actions.phaselessTypes, {\n    dragenter: true,\n    dragleave: true,\n    dropactivate: true,\n    dropdeactivate: true,\n    dropmove: true,\n    drop: true,\n  })\n  actions.methodDict.drop = 'dropzone'\n\n  scope.dynamicDrop = false\n\n  defaults.actions.drop = drop.defaults\n}\n\nfunction collectDrops ({ interactables }, draggableElement) {\n  const drops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const dropzone of interactables.list) {\n    if (!dropzone.options.drop.enabled) { continue }\n\n    const accept = dropzone.options.drop.accept\n\n    // test the draggable draggableElement against the dropzone's accept setting\n    if ((is.element(accept) && accept !== draggableElement) ||\n        (is.string(accept) &&\n        !domUtils.matchesSelector(draggableElement, accept)) ||\n        (is.func(accept) && !accept({ dropzone, draggableElement }))) {\n      continue\n    }\n\n    // query for new elements if necessary\n    const dropElements = is.string(dropzone.target)\n      ? dropzone._context.querySelectorAll(dropzone.target)\n      : is.array(dropzone.target) ? dropzone.target : [dropzone.target]\n\n    for (const dropzoneElement of dropElements) {\n      if (dropzoneElement !== draggableElement) {\n        drops.push({\n          dropzone,\n          element: dropzoneElement,\n        })\n      }\n    }\n  }\n\n  return drops\n}\n\nfunction fireActivationEvents (activeDrops, event) {\n  // loop through all active dropzones and trigger event\n  for (const { dropzone, element } of activeDrops.slice()) {\n    event.dropzone = dropzone\n\n    // set current element as event target\n    event.target = element\n    dropzone.fire(event)\n    event.propagationStopped = event.immediatePropagationStopped = false\n  }\n}\n\n// return a new array of possible drops. getActiveDrops should always be\n// called when a drag has just started or a drag event happens while\n// dynamicDrop is true\nfunction getActiveDrops (scope: Interact.Scope, dragElement: Interact.Element) {\n  // get dropzones and their elements that could receive the draggable\n  const activeDrops = collectDrops(scope, dragElement)\n\n  for (const activeDrop of activeDrops) {\n    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)\n  }\n\n  return activeDrops\n}\n\nfunction getDrop ({ dropState, interactable: draggable, element: dragElement }: Partial<Interact.Interaction>, dragEvent, pointerEvent) {\n  const validDrops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const { dropzone, element: dropzoneElement, rect } of dropState.activeDrops) {\n    validDrops.push(dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect)\n      ? dropzoneElement\n      : null)\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = domUtils.indexOfDeepestElement(validDrops)\n\n  return dropState.activeDrops[dropIndex] || null\n}\n\nfunction getDropEvents (interaction: Interact.Interaction, _pointerEvent, dragEvent) {\n  const { dropState } = interaction\n  const dropEvents = {\n    enter     : null,\n    leave     : null,\n    activate  : null,\n    deactivate: null,\n    move      : null,\n    drop      : null,\n  }\n\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = new DropEvent(dropState, dragEvent, 'dropactivate')\n\n    dropEvents.activate.target   = null\n    dropEvents.activate.dropzone = null\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = new DropEvent(dropState, dragEvent, 'dropdeactivate')\n\n    dropEvents.deactivate.target   = null\n    dropEvents.deactivate.dropzone = null\n  }\n\n  if (dropState.rejected) {\n    return dropEvents\n  }\n\n  if (dropState.cur.element !== dropState.prev.element) {\n    // if there was a previous dropzone, create a dragleave event\n    if (dropState.prev.dropzone) {\n      dropEvents.leave = new DropEvent(dropState, dragEvent, 'dragleave')\n\n      dragEvent.dragLeave    = dropEvents.leave.target   = dropState.prev.element\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone\n    }\n    // if dropzone is not null, create a dragenter event\n    if (dropState.cur.dropzone) {\n      dropEvents.enter = new DropEvent(dropState, dragEvent, 'dragenter')\n\n      dragEvent.dragEnter = dropState.cur.element\n      dragEvent.dropzone = dropState.cur.dropzone\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && dropState.cur.dropzone) {\n    dropEvents.drop = new DropEvent(dropState, dragEvent, 'drop')\n\n    dragEvent.dropzone = dropState.cur.dropzone\n    dragEvent.relatedTarget = dropState.cur.element\n  }\n  if (dragEvent.type === 'dragmove' && dropState.cur.dropzone) {\n    dropEvents.move = new DropEvent(dropState, dragEvent, 'dropmove')\n\n    dropEvents.move.dragmove = dragEvent\n    dragEvent.dropzone = dropState.cur.dropzone\n  }\n\n  return dropEvents\n}\n\nfunction fireDropEvents (interaction: Interact.Interaction, events) {\n  const { dropState } = interaction\n  const {\n    activeDrops,\n    cur,\n    prev,\n  } = dropState\n\n  if (events.leave) { prev.dropzone.fire(events.leave) }\n  if (events.enter) { cur.dropzone.fire(events.enter) }\n  if (events.move) { cur.dropzone.fire(events.move) }\n  if (events.drop) { cur.dropzone.fire(events.drop) }\n\n  if (events.deactivate) {\n    fireActivationEvents(activeDrops, events.deactivate)\n  }\n\n  dropState.prev.dropzone  = cur.dropzone\n  dropState.prev.element = cur.element\n}\n\nfunction onEventCreated ({ interaction, iEvent, event }: Interact.DoPhaseArg<'drag', Interact.EventPhase>, scope: Interact.Scope) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') { return }\n\n  const { dropState } = interaction\n\n  if (scope.dynamicDrop) {\n    dropState.activeDrops = getActiveDrops(scope, interaction.element)\n  }\n\n  const dragEvent = iEvent\n  const dropResult = getDrop(interaction, dragEvent, event)\n\n  // update rejected status\n  dropState.rejected = dropState.rejected &&\n    !!dropResult &&\n    dropResult.dropzone === dropState.cur.dropzone &&\n    dropResult.element === dropState.cur.element\n\n  dropState.cur.dropzone  = dropResult && dropResult.dropzone\n  dropState.cur.element = dropResult && dropResult.element\n\n  dropState.events = getDropEvents(interaction, event, dragEvent)\n}\n\nfunction dropzoneMethod (interactable: Interact.Interactable): Interact.DropzoneOptions\nfunction dropzoneMethod (interactable: Interact.Interactable, options: Interact.DropzoneOptions | boolean): Interact.Interactable\nfunction dropzoneMethod (interactable: Interact.Interactable, options?: Interact.DropzoneOptions | boolean) {\n  if (is.object(options)) {\n    interactable.options.drop.enabled = options.enabled !== false\n\n    if (options.listeners) {\n      const normalized = normalizeListeners(options.listeners)\n      // rename 'drop' to '' as it will be prefixed with 'drop'\n      const corrected = Object.keys(normalized).reduce((acc, type) => {\n        const correctedType = /^(enter|leave)/.test(type)\n          ? `drag${type}`\n          : /^(activate|deactivate|move)/.test(type)\n            ? `drop${type}`\n            : type\n\n        acc[correctedType] = normalized[type]\n\n        return acc\n      }, {})\n\n      interactable.off(interactable.options.drop.listeners)\n      interactable.on(corrected)\n      interactable.options.drop.listeners = corrected\n    }\n\n    if (is.func(options.ondrop)) { interactable.on('drop', options.ondrop) }\n    if (is.func(options.ondropactivate)) { interactable.on('dropactivate', options.ondropactivate) }\n    if (is.func(options.ondropdeactivate)) { interactable.on('dropdeactivate', options.ondropdeactivate) }\n    if (is.func(options.ondragenter)) { interactable.on('dragenter', options.ondragenter) }\n    if (is.func(options.ondragleave)) { interactable.on('dragleave', options.ondragleave) }\n    if (is.func(options.ondropmove)) { interactable.on('dropmove', options.ondropmove) }\n\n    if (/^(pointer|center)$/.test(options.overlap as string)) {\n      interactable.options.drop.overlap = options.overlap\n    }\n    else if (is.number(options.overlap)) {\n      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)\n    }\n    if ('accept' in options) {\n      interactable.options.drop.accept = options.accept\n    }\n    if ('checker' in options) {\n      interactable.options.drop.checker = options.checker\n    }\n\n    return interactable\n  }\n\n  if (is.bool(options)) {\n    interactable.options.drop.enabled = options\n\n    return interactable\n  }\n\n  return interactable.options.drop\n}\n\nfunction dropCheckMethod (\n  interactable: Interact.Interactable,\n  dragEvent: InteractEvent,\n  event: Interact.PointerEventType,\n  draggable: Interact.Interactable,\n  draggableElement: Interact.Element,\n  dropElement: Interact.Element,\n  rect: any,\n) {\n  let dropped = false\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || interactable.getRect(dropElement))) {\n    return (interactable.options.drop.checker\n      ? interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement)\n      : false)\n  }\n\n  const dropOverlap = interactable.options.drop.overlap\n\n  if (dropOverlap === 'pointer') {\n    const origin = getOriginXY(draggable, draggableElement, 'drag')\n    const page = pointerUtils.getPageXY(dragEvent)\n\n    page.x += origin.x\n    page.y += origin.y\n\n    const horizontal = (page.x > rect.left) && (page.x < rect.right)\n    const vertical   = (page.y > rect.top) && (page.y < rect.bottom)\n\n    dropped = horizontal && vertical\n  }\n\n  const dragRect = draggable.getRect(draggableElement)\n\n  if (dragRect && dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width  / 2\n    const cy = dragRect.top  + dragRect.height / 2\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom\n  }\n\n  if (dragRect && is.number(dropOverlap)) {\n    const overlapArea  = (Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *\n                          Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top)))\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)\n\n    dropped = overlapRatio >= dropOverlap\n  }\n\n  if (interactable.options.drop.checker) {\n    dropped = interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement)\n  }\n\n  return dropped\n}\n\nconst drop: Interact.Plugin = {\n  id: 'actions/drop',\n  install,\n  listeners: {\n    'interactions:before-action-start': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') { return }\n\n      interaction.dropState = {\n        cur: {\n          dropzone: null,\n          element: null,\n        },\n        prev: {\n          dropzone: null,\n          element: null,\n        },\n        rejected: null,\n        events: null,\n        activeDrops: [],\n      }\n    },\n\n    'interactions:after-action-start': ({ interaction, event, iEvent: dragEvent }: Interact.DoPhaseArg<'drag', Interact.EventPhase>, scope) => {\n      if (interaction.prepared.name !== 'drag') { return }\n\n      const { dropState } = interaction\n\n      // reset active dropzones\n      dropState.activeDrops = null\n      dropState.events = null\n      dropState.activeDrops = getActiveDrops(scope, interaction.element)\n      dropState.events = getDropEvents(interaction, event, dragEvent)\n\n      if (dropState.events.activate) {\n        fireActivationEvents(dropState.activeDrops, dropState.events.activate)\n        scope.fire('actions/drop:start', { interaction, dragEvent })\n      }\n    },\n\n    'interactions:action-move': onEventCreated,\n\n    'interactions:after-action-move': ({ interaction, iEvent: dragEvent }: Interact.DoPhaseArg<'drag', Interact.EventPhase>, scope) => {\n      if (interaction.prepared.name !== 'drag') { return }\n\n      fireDropEvents(interaction, interaction.dropState.events)\n\n      scope.fire('actions/drop:move', { interaction, dragEvent })\n      interaction.dropState.events = {}\n    },\n\n    'interactions:action-end': (arg: Interact.DoPhaseArg<'drag', Interact.EventPhase>, scope) => {\n      if (arg.interaction.prepared.name !== 'drag') { return }\n\n      const { interaction, iEvent: dragEvent } = arg\n\n      onEventCreated(arg, scope)\n      fireDropEvents(interaction, interaction.dropState.events)\n      scope.fire('actions/drop:end', { interaction, dragEvent })\n    },\n\n    'interactions:stop': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') { return }\n\n      const { dropState } = interaction\n\n      if (dropState) {\n        dropState.activeDrops = null\n        dropState.events = null\n        dropState.cur.dropzone = null\n        dropState.cur.element = null\n        dropState.prev.dropzone = null\n        dropState.prev.element = null\n        dropState.rejected = false\n      }\n    },\n  },\n  getActiveDrops,\n  getDrop,\n  getDropEvents,\n  fireDropEvents,\n  defaults: {\n    enabled: false,\n    accept : null,\n    overlap: 'pointer',\n  } as Interact.DropzoneOptions,\n}\n\nexport default drop\n","import * as Interact from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nexport type GesturableMethod = Interact.ActionMethod<Interact.GesturableOptions>\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    gesture?: {\n      angle: number           // angle from first to second touch\n      distance: number\n      scale: number           // gesture.distance / gesture.startDistance\n      startAngle: number      // angle of line joining two touches\n      startDistance: number   // distance between two touches of touchStart\n    }\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    gesturable: GesturableMethod\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    gesture: Interact.GesturableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    gesture?: typeof gesture\n  }\n}\n\nexport interface GestureEvent extends Interact.InteractEvent<'gesture'> {\n  distance: number\n  angle: number\n  da: number // angle change\n  scale: number // ratio of distance start to current event\n  ds: number // scale change\n  box: Interact.Rect // enclosing box of all points\n  touches: Interact.PointerType[]\n}\n\nexport interface GestureSignalArg extends Interact.DoPhaseArg<'gesture', Interact.EventPhase> {\n  iEvent: GestureEvent\n  interaction: Interact.Interaction<'gesture'>\n}\n\nfunction install (scope: Interact.Scope) {\n  const {\n    actions,\n    Interactable,\n    defaults,\n  } = scope\n\n  /**\n   * ```js\n   * interact(element).gesturable({\n   *     onstart: function (event) {},\n   *     onmove : function (event) {},\n   *     onend  : function (event) {},\n   *\n   *     // limit multiple gestures.\n   *     // See the explanation in {@link Interactable.draggable} example\n   *     max: Infinity,\n   *     maxPerElement: 1,\n   * })\n   *\n   * var isGestureable = interact(element).gesturable()\n   * ```\n   *\n   * Gets or sets whether multitouch gestures can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on gesture events (makes the Interactable gesturable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of gesture events, or this Interactable\n   */\n  Interactable.prototype.gesturable = function (this: Interact.Interactable, options: Interact.GesturableOptions | boolean) {\n    if (is.object(options)) {\n      this.options.gesture.enabled = options.enabled !== false\n      this.setPerAction('gesture', options)\n      this.setOnEvents('gesture', options)\n\n      return this\n    }\n\n    if (is.bool(options)) {\n      this.options.gesture.enabled = options\n\n      return this\n    }\n\n    return this.options.gesture as Interact.Options\n  } as GesturableMethod\n\n  actions.map.gesture = gesture\n  actions.methodDict.gesture = 'gesturable'\n\n  defaults.actions.gesture = gesture.defaults\n}\n\nfunction updateGestureProps ({ interaction, iEvent, phase }: GestureSignalArg) {\n  if (interaction.prepared.name !== 'gesture') { return }\n\n  const pointers = interaction.pointers.map(p => p.pointer)\n  const starting = phase === 'start'\n  const ending = phase === 'end'\n  const deltaSource = interaction.interactable.options.deltaSource\n\n  iEvent.touches = [pointers[0], pointers[1]]\n\n  if (starting) {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box      = pointerUtils.touchBBox(pointers)\n    iEvent.scale    = 1\n    iEvent.ds       = 0\n    iEvent.angle    = pointerUtils.touchAngle(pointers, deltaSource)\n    iEvent.da       = 0\n\n    interaction.gesture.startDistance = iEvent.distance\n    interaction.gesture.startAngle = iEvent.angle\n  }\n  else if (ending) {\n    const prevEvent = interaction.prevEvent as GestureEvent\n\n    iEvent.distance = prevEvent.distance\n    iEvent.box      = prevEvent.box\n    iEvent.scale    = prevEvent.scale\n    iEvent.ds       = 0\n    iEvent.angle    = prevEvent.angle\n    iEvent.da       = 0\n  }\n  else {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box      = pointerUtils.touchBBox(pointers)\n    iEvent.scale    = iEvent.distance / interaction.gesture.startDistance\n    iEvent.angle    = pointerUtils.touchAngle(pointers, deltaSource)\n\n    iEvent.ds = iEvent.scale - interaction.gesture.scale\n    iEvent.da = iEvent.angle - interaction.gesture.angle\n  }\n\n  interaction.gesture.distance = iEvent.distance\n  interaction.gesture.angle = iEvent.angle\n\n  if (is.number(iEvent.scale) &&\n      iEvent.scale !== Infinity &&\n      !isNaN(iEvent.scale)) {\n    interaction.gesture.scale = iEvent.scale\n  }\n}\n\nconst gesture: Interact.Plugin = {\n  id: 'actions/gesture',\n  before: ['actions/drag', 'actions/resize'],\n  install,\n  listeners: {\n    'interactions:action-start': updateGestureProps,\n    'interactions:action-move': updateGestureProps,\n    'interactions:action-end': updateGestureProps,\n\n    'interactions:new': ({ interaction }) => {\n      interaction.gesture = {\n        angle: 0,\n        distance: 0,\n        scale: 1,\n        startAngle: 0,\n        startDistance: 0,\n      }\n    },\n\n    'auto-start:check': arg => {\n      if (arg.interaction.pointers.length < 2) {\n        return undefined\n      }\n\n      const gestureOptions = arg.interactable.options.gesture\n\n      if (!(gestureOptions && gestureOptions.enabled)) {\n        return undefined\n      }\n\n      arg.action = { name: 'gesture' }\n\n      return false\n    },\n  },\n\n  defaults: {\n  },\n\n  getCursor () {\n    return ''\n  },\n}\n\nexport default gesture\n","import { Interaction } from '@interactjs/core/Interaction'\nimport { Scope } from '@interactjs/core/scope'\nimport * as Interact from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nexport type EdgeName = 'top' | 'left' | 'bottom' | 'right'\n\nexport type ResizableMethod = Interact.ActionMethod<Interact.ResizableOptions>\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    resizable: ResizableMethod\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    resizeAxes: 'x' | 'y' | 'xy'\n    resizeStartAspectRatio: number\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    resize: Interact.ResizableOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface ActionMap {\n    resize?: typeof resize\n  }\n}\n\nexport interface ResizeEvent<P extends Interact.EventPhase = Interact.EventPhase> extends Interact.InteractEvent<'resize', P> {\n  deltaRect?: Interact.FullRect\n  edges?: Interact.ActionProps['edges']\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    browser,\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n    defaults,\n  } = scope\n\n  // Less Precision with touch input\n\n  resize.cursors = initCursors(browser)\n  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10\n\n  /**\n   * ```js\n   * interact(element).resizable({\n   *   onstart: function (event) {},\n   *   onmove : function (event) {},\n   *   onend  : function (event) {},\n   *\n   *   edges: {\n   *     top   : true,       // Use pointer coords to check for resize.\n   *     left  : false,      // Disable resizing from left edge.\n   *     bottom: '.resize-s',// Resize if pointer target matches selector\n   *     right : handleEl    // Resize if pointer target is the given Element\n   *   },\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height are adjusted at a 1:1 ratio.\n   *     square: false,\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height maintain the aspect ratio they had when resizing started.\n   *     preserveAspectRatio: false,\n   *\n   *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   *   // 'negate' will allow the rect to have negative width/height\n   *   // 'reposition' will keep the width/height positive by swapping\n   *   // the top and bottom edges and/or swapping the left and right edges\n   *   invert: 'none' || 'negate' || 'reposition'\n   *\n   *   // limit multiple resizes.\n   *   // See the explanation in the {@link Interactable.draggable} example\n   *   max: Infinity,\n   *   maxPerElement: 1,\n   * })\n   *\n   * var isResizeable = interact(element).resizable()\n   * ```\n   *\n   * Gets or sets whether resize actions can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on resize events (object makes the Interactable\n   * resizable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of resize elements, or this Interactable\n   */\n  Interactable.prototype.resizable = function (this: Interact.Interactable, options: Interact.ResizableOptions | boolean) {\n    return resizable(this, options, scope)\n  } as ResizableMethod\n\n  actions.map.resize = resize\n  actions.methodDict.resize = 'resizable'\n\n  defaults.actions.resize = resize.defaults\n}\n\nfunction resizeChecker (arg) {\n  const { interaction, interactable, element, rect, buttons } = arg\n\n  if (!rect) { return undefined }\n\n  const page = extend({}, interaction.coords.cur.page)\n  const resizeOptions = interactable.options.resize\n\n  if (\n    !(resizeOptions && resizeOptions.enabled) ||\n    // check mouseButton setting if the pointer is down\n    (interaction.pointerIsDown &&\n     /mouse|pointer/.test(interaction.pointerType) &&\n   (buttons & resizeOptions.mouseButtons) === 0)\n  ) {\n    return undefined\n  }\n\n  // if using resize.edges\n  if (is.object(resizeOptions.edges)) {\n    const resizeEdges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false,\n    }\n\n    for (const edge in resizeEdges) {\n      resizeEdges[edge] = checkResizeEdge(edge,\n        resizeOptions.edges[edge],\n        page,\n        interaction._latestPointer.eventTarget,\n        element,\n        rect,\n        resizeOptions.margin || resize.defaultMargin)\n    }\n\n    resizeEdges.left = resizeEdges.left && !resizeEdges.right\n    resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom\n\n    if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n      arg.action = {\n        name: 'resize',\n        edges: resizeEdges,\n      }\n    }\n  }\n  else {\n    const right  = resizeOptions.axis !== 'y' && page.x > (rect.right  - resize.defaultMargin)\n    const bottom = resizeOptions.axis !== 'x' && page.y > (rect.bottom - resize.defaultMargin)\n\n    if (right || bottom) {\n      arg.action = {\n        name: 'resize',\n        axes: (right ? 'x' : '') + (bottom ? 'y' : ''),\n      }\n    }\n  }\n\n  return arg.action ? false : undefined\n}\n\nfunction resizable (interactable: Interact.Interactable, options: Interact.OrBoolean<Interact.ResizableOptions> | boolean, scope: Scope) {\n  if (is.object(options)) {\n    interactable.options.resize.enabled = options.enabled !== false\n    interactable.setPerAction('resize', options)\n    interactable.setOnEvents('resize', options)\n\n    if (is.string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) {\n      interactable.options.resize.axis = options.axis\n    }\n    else if (options.axis === null) {\n      interactable.options.resize.axis = scope.defaults.actions.resize.axis\n    }\n\n    if (is.bool(options.preserveAspectRatio)) {\n      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio\n    }\n    else if (is.bool(options.square)) {\n      interactable.options.resize.square = options.square\n    }\n\n    return interactable\n  }\n  if (is.bool(options)) {\n    interactable.options.resize.enabled = options\n\n    return interactable\n  }\n  return interactable.options.resize\n}\n\nfunction checkResizeEdge (\n  name: string,\n  value: any,\n  page: Interact.Point,\n  element: Node,\n  interactableElement: Interact.Element,\n  rect: Interact.Rect,\n  margin: number,\n) {\n  // false, '', undefined, null\n  if (!value) { return false }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width  = is.number(rect.width) ? rect.width  : rect.right  - rect.left\n    const height = is.number(rect.height) ? rect.height : rect.bottom - rect.top\n\n    // don't use margin greater than half the relevent dimension\n    margin = Math.min(margin, Math.abs((name === 'left' || name === 'right' ? width : height) / 2))\n\n    if (width < 0) {\n      if      (name === 'left')  { name = 'right' }\n      else if (name === 'right') { name = 'left'  }\n    }\n    if (height < 0) {\n      if      (name === 'top')    { name = 'bottom' }\n      else if (name === 'bottom') { name = 'top'    }\n    }\n\n    if (name === 'left') { return page.x < ((width  >= 0 ? rect.left : rect.right) + margin) }\n    if (name === 'top') { return page.y < ((height >= 0 ? rect.top : rect.bottom) + margin) }\n\n    if (name === 'right') { return page.x > ((width  >= 0 ? rect.right : rect.left) - margin) }\n    if (name === 'bottom') { return page.y > ((height >= 0 ? rect.bottom : rect.top) - margin) }\n  }\n\n  // the remaining checks require an element\n  if (!is.element(element)) { return false }\n\n  return is.element(value)\n  // the value is an element to use as a resize handle\n    ? value === element\n    // otherwise check if element matches value as selector\n    : dom.matchesUpTo(element, value, interactableElement)\n}\n\nfunction initCursors (browser: typeof import ('@interactjs/utils/browser').default) {\n  return (browser.isIe9 ? {\n    x : 'e-resize',\n    y : 's-resize',\n    xy: 'se-resize',\n\n    top        : 'n-resize',\n    left       : 'w-resize',\n    bottom     : 's-resize',\n    right      : 'e-resize',\n    topleft    : 'se-resize',\n    bottomright: 'se-resize',\n    topright   : 'ne-resize',\n    bottomleft : 'ne-resize',\n  } : {\n    x : 'ew-resize',\n    y : 'ns-resize',\n    xy: 'nwse-resize',\n\n    top        : 'ns-resize',\n    left       : 'ew-resize',\n    bottom     : 'ns-resize',\n    right      : 'ew-resize',\n    topleft    : 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright   : 'nesw-resize',\n    bottomleft : 'nesw-resize',\n  })\n}\n\nfunction start ({ iEvent, interaction }: { iEvent: Interact.InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {\n    return\n  }\n\n  const resizeEvent = iEvent as ResizeEvent\n  const rect = interaction.rect\n\n  interaction._rects = {\n    start: extend({}, rect),\n    corrected: extend({}, rect),\n    previous: extend({}, rect),\n    delta: {\n      left: 0,\n      right : 0,\n      width : 0,\n      top : 0,\n      bottom: 0,\n      height: 0,\n    },\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction move ({ iEvent, interaction }: { iEvent: Interact.InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) { return }\n\n  const resizeEvent = iEvent as ResizeEvent\n  const resizeOptions = interaction.interactable.options.resize\n  const invert = resizeOptions.invert\n  const invertible = invert === 'reposition' || invert === 'negate'\n\n  // eslint-disable-next-line no-shadow\n  const current = interaction.rect\n  const { start: startRect, corrected, delta: deltaRect, previous } = interaction._rects\n\n  extend(previous, corrected)\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    extend(corrected, current)\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      if (corrected.top > corrected.bottom) {\n        const swap = corrected.top\n\n        corrected.top = corrected.bottom\n        corrected.bottom = swap\n      }\n      if (corrected.left > corrected.right) {\n        const swap = corrected.left\n\n        corrected.left = corrected.right\n        corrected.right = swap\n      }\n    }\n  }\n  else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    corrected.top    = Math.min(current.top, startRect.bottom)\n    corrected.bottom = Math.max(current.bottom, startRect.top)\n    corrected.left   = Math.min(current.left, startRect.right)\n    corrected.right  = Math.max(current.right, startRect.left)\n  }\n\n  corrected.width  = corrected.right  - corrected.left\n  corrected.height = corrected.bottom - corrected.top\n\n  for (const edge in corrected) {\n    deltaRect[edge] = corrected[edge] - previous[edge]\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = corrected\n  resizeEvent.deltaRect = deltaRect\n}\n\nfunction end ({ iEvent, interaction }: { iEvent: Interact.InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) { return }\n\n  const resizeEvent = iEvent as ResizeEvent\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction updateEventAxes ({ iEvent, interaction }: { iEvent: Interact.InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.resizeAxes) { return }\n\n  const options = interaction.interactable.options\n  const resizeEvent = iEvent as ResizeEvent\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = resizeEvent.delta.y\n    }\n    else {\n      resizeEvent.delta.y = resizeEvent.delta.x\n    }\n    resizeEvent.axes = 'xy'\n  }\n  else {\n    resizeEvent.axes = interaction.resizeAxes\n\n    if (interaction.resizeAxes === 'x') {\n      resizeEvent.delta.y = 0\n    }\n    else if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = 0\n    }\n  }\n}\n\nconst resize: Interact.Plugin = {\n  id: 'actions/resize',\n  before: ['actions/drag'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.resizeAxes = 'xy'\n    },\n\n    'interactions:action-start': arg => {\n      start(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-move': arg => {\n      move(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-end': end,\n    'auto-start:check': resizeChecker,\n  },\n\n  defaults: {\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  } as Interact.ResizableOptions,\n\n  cursors: null as ReturnType<typeof initCursors>,\n\n  getCursor ({ edges, axis, name }: Interact.ActionProps) {\n    const cursors = resize.cursors\n    let result: string = null\n\n    if (axis) {\n      result = cursors[name + axis]\n    }\n    else if (edges) {\n      let cursorKey = ''\n\n      for (const edge of ['top', 'bottom', 'left', 'right']) {\n        if (edges[edge]) {\n          cursorKey += edge\n        }\n      }\n\n      result = cursors[cursorKey]\n    }\n\n    return result\n  },\n\n  defaultMargin: null as number,\n}\n\nexport default resize\n","import * as Interact from '@interactjs/types/index'\n\nimport drag from './drag/plugin'\nimport drop from './drop/plugin'\nimport gesture from './gesture/plugin'\nimport resize from './resize/plugin'\n\nexport default {\n  id: 'actions',\n  install (scope: Interact.Scope) {\n    scope.usePlugin(gesture)\n    scope.usePlugin(resize)\n    scope.usePlugin(drag)\n    scope.usePlugin(drop)\n  },\n}\n","export type ArrangeEvent = {}\nexport type ArrangeMode = {}\n\nexport default {}\n","let lastTime = 0\nlet request: typeof requestAnimationFrame\nlet cancel: typeof cancelAnimationFrame\n\nfunction init (window: Window) {\n  request = window.requestAnimationFrame\n  cancel = window.cancelAnimationFrame\n\n  if (!request) {\n    const vendors = ['ms', 'moz', 'webkit', 'o']\n\n    for (const vendor of vendors) {\n      request = window[`${vendor}RequestAnimationFrame` as 'requestAnimationFrame']\n      cancel = window[`${vendor}CancelAnimationFrame` as 'cancelAnimationFrame'] ||\n        window[`${vendor}CancelRequestAnimationFrame` as 'cancelAnimationFrame']\n    }\n  }\n\n  request = request && request.bind(window)\n  cancel = cancel && cancel.bind(window)\n\n  if (!request) {\n    request = callback => {\n      const currTime = Date.now()\n      const timeToCall = Math.max(0, 16 - (currTime - lastTime))\n      // eslint-disable-next-line standard/no-callback-literal\n      const token = window.setTimeout(() => { callback(currTime + timeToCall) },\n        timeToCall)\n\n      lastTime = currTime + timeToCall\n      return token\n    }\n\n    cancel = token => clearTimeout(token)\n  }\n}\n\nexport default {\n  request: (callback: FrameRequestCallback) => request(callback),\n  cancel: (token: number) => cancel(token),\n  init,\n}\n","import * as Interact from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport { getStringOptionResult } from '@interactjs/utils/rect'\nimport { getWindow } from '@interactjs/utils/window'\n\ntype Scope = import ('@interactjs/core/scope').Scope\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoScroll: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoScroll?: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    autoScroll?: AutoScrollOptions\n  }\n}\n\nexport interface AutoScrollOptions {\n  container?: Window | HTMLElement\n  margin?: number\n  distance?: number\n  interval?: number\n  speed?: number\n  enabled?: boolean\n}\n\nfunction install (scope: Scope) {\n  const {\n    defaults,\n    actions,\n  } = scope\n\n  scope.autoScroll = autoScroll\n  autoScroll.now = () => scope.now()\n\n  actions.phaselessTypes.autoscroll = true\n  defaults.perAction.autoScroll = autoScroll.defaults\n}\n\nconst autoScroll = {\n  defaults: {\n    enabled  : false,\n    margin   : 60,\n\n    // the item that is scrolled (Window or HTMLElement)\n    container: null as AutoScrollOptions['container'],\n\n    // the scroll speed in pixels per second\n    speed    : 300,\n  } as AutoScrollOptions,\n\n  now: Date.now,\n\n  interaction: null as Interact.Interaction,\n  i: 0, // the handle returned by window.setInterval\n\n  // Direction each pulse is to scroll in\n  x: 0,\n  y: 0,\n\n  isScrolling: false,\n  prevTime: 0,\n  margin: 0,\n  speed: 0,\n\n  start (interaction: Interact.Interaction) {\n    autoScroll.isScrolling = true\n    raf.cancel(autoScroll.i)\n\n    interaction.autoScroll = autoScroll\n    autoScroll.interaction = interaction\n    autoScroll.prevTime = autoScroll.now()\n    autoScroll.i = raf.request(autoScroll.scroll)\n  },\n\n  stop () {\n    autoScroll.isScrolling = false\n    if (autoScroll.interaction) {\n      autoScroll.interaction.autoScroll = null\n    }\n    raf.cancel(autoScroll.i)\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll () {\n    const { interaction } = autoScroll\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n    const now = autoScroll.now()\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000\n    // displacement\n    const s = options.speed * dt\n\n    if (s >= 1) {\n      const scrollBy = {\n        x: autoScroll.x * s,\n        y: autoScroll.y * s,\n      }\n\n      if (scrollBy.x || scrollBy.y) {\n        const prevScroll = getScroll(container)\n\n        if (is.window(container)) {\n          container.scrollBy(scrollBy.x, scrollBy.y)\n        }\n        else if (container) {\n          container.scrollLeft += scrollBy.x\n          container.scrollTop  += scrollBy.y\n        }\n\n        const curScroll = getScroll(container)\n        const delta = {\n          x: curScroll.x - prevScroll.x,\n          y: curScroll.y - prevScroll.y,\n        }\n\n        if (delta.x || delta.y) {\n          interactable.fire({\n            type: 'autoscroll',\n            target: element,\n            interactable,\n            delta,\n            interaction,\n            container,\n          })\n        }\n      }\n\n      autoScroll.prevTime = now\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i)\n      autoScroll.i = raf.request(autoScroll.scroll)\n    }\n  },\n  check (interactable: Interact.Interactable, actionName: Interact.ActionName) {\n    const options = interactable.options\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled\n  },\n  onInteractionMove<T extends Interact.ActionName> ({ interaction, pointer }: { interaction: Interact.Interaction<T>, pointer: Interact.PointerType }) {\n    if (!(interaction.interacting() &&\n          autoScroll.check(interaction.interactable, interaction.prepared.name))) {\n      return\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0\n      return\n    }\n\n    let top: boolean\n    let right: boolean\n    let bottom: boolean\n    let left: boolean\n\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n\n    if (is.window(container)) {\n      left   = pointer.clientX < autoScroll.margin\n      top    = pointer.clientY < autoScroll.margin\n      right  = pointer.clientX > container.innerWidth  - autoScroll.margin\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin\n    }\n    else {\n      const rect = domUtils.getElementClientRect(container)\n\n      left   = pointer.clientX < rect.left   + autoScroll.margin\n      top    = pointer.clientY < rect.top    + autoScroll.margin\n      right  = pointer.clientX > rect.right  - autoScroll.margin\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin\n    }\n\n    autoScroll.x = (right ? 1 : left ? -1 : 0)\n    autoScroll.y = (bottom ? 1 :  top ? -1 : 0)\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin\n      autoScroll.speed  = options.speed\n\n      autoScroll.start(interaction)\n    }\n  },\n}\n\nexport function getContainer (value: any, interactable: Interact.Interactable, element: Interact.Element) {\n  return (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow(element)\n}\n\nexport function getScroll (container: any) {\n  if (is.window(container)) { container = window.document.body }\n\n  return { x: container.scrollLeft, y: container.scrollTop }\n}\n\nexport function getScrollSize (container: any) {\n  if (is.window(container)) { container = window.document.body }\n\n  return { x: container.scrollWidth, y: container.scrollHeight }\n}\n\nexport function getScrollSizeDelta<T extends Interact.ActionName> ({ interaction, element }: {\n  interaction: Partial<Interact.Interaction<T>>\n  element: Interact.Element\n}, func: any) {\n  const scrollOptions = interaction && interaction.interactable.options[interaction.prepared.name].autoScroll\n\n  if (!scrollOptions || !scrollOptions.enabled) {\n    func()\n    return { x: 0, y: 0 }\n  }\n\n  const scrollContainer = getContainer(\n    scrollOptions.container,\n    interaction.interactable,\n    element,\n  )\n\n  const prevSize = getScroll(scrollContainer)\n  func()\n  const curSize = getScroll(scrollContainer)\n\n  return {\n    x: curSize.x - prevSize.x,\n    y: curSize.y - prevSize.y,\n  }\n}\n\nconst autoScrollPlugin: Interact.Plugin = {\n  id: 'auto-scroll',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoScroll = null\n    },\n\n    'interactions:destroy': ({ interaction }) => {\n      interaction.autoScroll = null\n      autoScroll.stop()\n      if (autoScroll.interaction) {\n        autoScroll.interaction = null\n      }\n    },\n\n    'interactions:stop': autoScroll.stop,\n\n    'interactions:action-move': (arg: any) => autoScroll.onInteractionMove(arg),\n  },\n}\n\nexport default autoScrollPlugin\n","import * as Interact from '@interactjs/types/index'\n\nimport { window } from './window'\n\nexport function warnOnce<T> (this: T, method: (...args: any[]) => any, message: string) {\n  let warned = false\n\n  return function (this: T) {\n    if (!warned) {\n      (window as any).console.warn(message)\n      warned = true\n    }\n\n    return method.apply(this, arguments)\n  }\n}\n\nexport function copyAction (dest: Interact.ActionProps, src: Interact.ActionProps) {\n  dest.name  = src.name\n  dest.axis  = src.axis\n  dest.edges = src.edges\n\n  return dest\n}\n","import * as Interact from '@interactjs/types/index'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: (\n      this: Interact.Interactable,\n      pointer: Interact.PointerType,\n      event: Interact.PointerEventType,\n      interaction: Interact.Interaction,\n      element: Interact.Element,\n    ) => Interact.ActionProps | null\n    styleCursor: typeof styleCursor\n    actionChecker: typeof actionChecker\n    ignoreFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n    allowFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n  }\n}\n\nfunction install (scope: Interact.Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n  } = scope\n\n  Interactable.prototype.getAction = function getAction (\n    this: Interact.Interactable,\n    pointer: Interact.PointerType,\n    event: Interact.PointerEventType,\n    interaction: Interact.Interaction,\n    element: Interact.Element,\n  ): Interact.ActionProps {\n    const action = defaultActionChecker(this, event, interaction, element, scope)\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\n    }\n\n    return action\n  }\n\n  /**\n   * ```js\n   * interact(element, { ignoreFrom: document.getElementById('no-action') })\n   * // or\n   * interact(element).ignoreFrom('input, textarea, a')\n   * ```\n   * @deprecated\n   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n   * of it's parents match the given CSS selector or Element, no\n   * drag/resize/gesture is started.\n   *\n   * Don't use this method. Instead set the `ignoreFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * @example\n   * interact(targett)\n   *   .draggable({\n   *     ignoreFrom: 'input, textarea, a[href]'',\n   *   })\n   *   .pointerEvents({\n   *     ignoreFrom: '[no-pointer]',\n   *   })\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to not ignore any elements\n   * @return {string | Element | object} The current ignoreFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interact.Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  /**\n   * @deprecated\n   *\n   * A drag/resize/gesture is started only If the target of the `mousedown`,\n   * `pointerdown` or `touchstart` event or any of it's parents match the given\n   * CSS selector or Element.\n   *\n   * Don't use this method. Instead set the `allowFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * @example\n   * interact(targett)\n   *   .resizable({\n   *     allowFrom: '.resize-handle',\n   *   .pointerEvents({\n   *     allowFrom: '.handle',,\n   *   })\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to allow from any element\n   * @return {string | Element | object} The current allowFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interact.Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  /**\n   * ```js\n   * interact('.resize-drag')\n   *   .resizable(true)\n   *   .draggable(true)\n   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   *\n   *   if (interact.matchesSelector(event.target, '.drag-handle')) {\n   *     // force drag with handle target\n   *     action.name = drag\n   *   }\n   *   else {\n   *     // resize from the top and right edges\n   *     action.name  = 'resize'\n   *     action.edges = { top: true, right: true }\n   *   }\n   *\n   *   return action\n   * })\n   * ```\n   *\n   * Returns or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   * @param {function | null} [checker] A function which takes a pointer event,\n   * defaultAction string, interactable, element and interaction as parameters\n   * and returns an object with name property 'drag' 'resize' or 'gesture' and\n   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n   * props.\n   * @return {Function | Interactable} The checker function or this Interactable\n   */\n  Interactable.prototype.actionChecker = actionChecker\n\n  /**\n   * Returns or sets whether the the cursor should be changed depending on the\n   * action that would be performed if the mouse were pressed and dragged.\n   *\n   * @param {boolean} [newValue]\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.styleCursor = styleCursor\n}\n\nfunction defaultActionChecker (\n  interactable: Interact.Interactable,\n  event: Interact.PointerEventType,\n  interaction: Interact.Interaction,\n  element: Interact.Element,\n  scope: Interact.Scope,\n) {\n  const rect = interactable.getRect(element)\n  const buttons = (event as MouseEvent).buttons || ({\n    0: 1,\n    1: 4,\n    3: 8,\n    4: 16,\n  })[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  const arg = {\n    action: null,\n    interactable,\n    interaction,\n    element,\n    rect,\n    buttons,\n  }\n\n  scope.fire('auto-start:check', arg)\n\n  return arg.action\n}\n\nfunction styleCursor (this: Interact.Interactable): boolean\nfunction styleCursor (this: Interact.Interactable, newValue: boolean): typeof this\nfunction styleCursor (this: Interact.Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker (this: Interact.Interactable, checker: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nexport default {\n  id: 'auto-start/interactableMethods',\n  install,\n}\n","import * as Interact from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\nimport InteractableMethods from './InteractableMethods'\n\ndeclare module '@interactjs/core/interactStatic' {\n  export interface InteractStatic {\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Interact.SignalArgs['interactions:move']\n    'autoStart:prepared': { interaction: Interact.Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Interact.Element\n    ignoreFrom?: string | Interact.Element\n    cursorChecker?: Interact.CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons?: 0 | 1 | 2 | 4 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interact.Interactable\n  interaction: Interact.Interaction\n  element: Interact.Element\n  action: Interact.ActionProps\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Interact.Element\n}\n\nfunction install (scope: Interact.Scope) {\n  const {\n    interactStatic: interact,\n    defaults,\n  } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom:  null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  /**\n   * Returns or sets the maximum number of concurrent interactions allowed.  By\n   * default only 1 interaction is allowed at a time (for backwards\n   * compatibility). To allow multiple interactions on the same Interactables and\n   * elements, you need to enable it in the draggable, resizable and gesturable\n   * `'max'` and `'maxPerElement'` options.\n   *\n   * @alias module:interact.maxInteractions\n   *\n   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n   */\n  interact.maxInteractions = (newValue: number) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown ({ interaction, pointer, event, eventTarget }: Interact.SignalArgs['interactions:down'], scope: Interact.Scope) {\n  if (interaction.interacting()) { return }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove ({ interaction, pointer, event, eventTarget }: Interact.SignalArgs['interactions:move'], scope: Interact.Scope) {\n  if (interaction.pointerType !== 'mouse' ||\n      interaction.pointerIsDown ||\n      interaction.interacting()) { return }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Interact.Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove (arg: Interact.SignalArgs['interactions:move'], scope: Interact.Scope) {\n  const { interaction } = arg\n\n  if (!interaction.pointerIsDown ||\n      interaction.interacting() ||\n      !interaction.pointerWasMoved ||\n      !interaction.prepared.name) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = interaction.prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (interactable.options[actionName].manualStart ||\n        !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)) {\n      interaction.stop()\n    }\n    else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop ({ interaction }: { interaction: Interact.Interaction }, scope: Interact.Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends Interact.ActionName> (\n  action: Interact.ActionProps<T>,\n  interactable: Interact.Interactable,\n  element: Interact.Element,\n  eventTarget: Node,\n  scope: Interact.Scope,\n) {\n  if (interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n      interactable.options[action.name].enabled &&\n      withinInteractionLimit(interactable, element, action, scope)) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches (\n  interaction: Interact.Interaction,\n  pointer: Interact.PointerType,\n  event: Interact.PointerEventType,\n  matches: Interact.Interactable[],\n  matchElements: Interact.Element[],\n  eventTarget: Node,\n  scope: Interact.Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) { continue }\n\n    const action = validateAction(\n      matchAction,\n      match,\n      matchElement,\n      eventTarget,\n      scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo (\n  interaction: Interact.Interaction,\n  pointer: Interact.PointerType,\n  event: Interact.PointerEventType,\n  eventTarget: Node,\n  scope: Interact.Scope,\n) {\n  let matches: Interact.Interactable[] = []\n  let matchElements: Interact.Element[] = []\n\n  let element = eventTarget as Interact.Element\n\n  function pushMatches (interactable: Interact.Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope)\n\n    if (actionInfo.action &&\n      !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Interact.Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare (\n  interaction: Interact.Interaction,\n  { action, interactable, element }: {\n    action: Interact.ActionProps\n    interactable: Interact.Interactable\n    element: Interact.Element\n  },\n  scope: Interact.Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name\n    ? interactable.getRect(element)\n    : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends Interact.ActionName> (\n  interactable: Interact.Interactable,\n  element: Interact.Element,\n  action: Interact.ActionProps<T>,\n  scope: Interact.Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) { return false }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) { continue }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) { continue }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions (newValue: any, scope: Interact.Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor (element: Interact.Element, cursor: string, scope: Interact.Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends Interact.ActionName> (interaction: Interact.Interaction<T>, scope: Interact.Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker: Interact.CursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    }\n    else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Interact.Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n} as Interact.Plugin\n\nexport default autoStart\n","import * as Interact from '@interactjs/types/index'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\n\nimport autoStart from './base'\n\nfunction beforeStart ({ interaction, eventTarget, dx, dy }: Interact.SignalArgs['interactions:move'], scope: Interact.Scope) {\n  if (interaction.prepared.name !== 'drag') { return }\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx)\n  const absY = Math.abs(dy)\n  const targetOptions = interaction.interactable.options.drag\n  const startAxis = targetOptions.startAxis\n  const currentAxis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy')\n\n  interaction.prepared.axis = targetOptions.lockAxis === 'start'\n    ? currentAxis[0]  as 'x' | 'y' // always lock to one axis even if currentAxis === 'xy'\n    : targetOptions.lockAxis\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    interaction.prepared.name = null\n\n    // then try to get a drag from another ineractable\n    let element = eventTarget as Interact.Element\n\n    const getDraggable = function (interactable: Interact.Interactable): Interact.Interactable | void {\n      if (interactable === interaction.interactable) { return }\n\n      const options = interaction.interactable.options.drag\n\n      if (!options.manualStart &&\n          interactable.testIgnoreAllow(options, element, eventTarget)) {\n        const action = interactable.getAction(\n          interaction.downPointer, interaction.downEvent, interaction, element)\n\n        if (action &&\n            action.name === 'drag' &&\n            checkStartAxis(currentAxis, interactable) &&\n            autoStart.validateAction(action, interactable, element, eventTarget, scope)) {\n          return interactable\n        }\n      }\n    }\n\n    // check all interactables\n    while (is.element(element)) {\n      const interactable = scope.interactables.forEachMatch(element, getDraggable)\n\n      if (interactable) {\n        interaction.prepared.name = 'drag'\n        interaction.interactable = interactable\n        interaction.element = element\n        break\n      }\n\n      element = parentNode(element) as Interact.Element\n    }\n  }\n}\n\nfunction checkStartAxis (startAxis: string, interactable: Interact.Interactable) {\n  if (!interactable) { return false }\n\n  const thisAxis = interactable.options.drag.startAxis\n\n  return (startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis)\n}\n\nexport default {\n  id: 'auto-start/dragAxis',\n  listeners: { 'autoStart:before-start': beforeStart },\n}\n","import * as Interact from '@interactjs/types/index'\n\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    hold?: number\n    delay?: number\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoStartHoldTimer?: any\n  }\n}\n\nfunction install (scope: Interact.Scope) {\n  const {\n    defaults,\n  } = scope\n\n  scope.usePlugin(basePlugin)\n\n  defaults.perAction.hold = 0\n  defaults.perAction.delay = 0\n}\n\nfunction getHoldDuration (interaction: Interact.Interaction) {\n  const actionName = interaction.prepared && interaction.prepared.name\n\n  if (!actionName) { return null }\n\n  const options = interaction.interactable.options\n\n  return options[actionName].hold || options[actionName].delay\n}\n\nexport default {\n  id: 'auto-start/hold',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoStartHoldTimer = null\n    },\n\n    'autoStart:prepared': ({ interaction }) => {\n      const hold = getHoldDuration(interaction)\n\n      if (hold > 0) {\n        interaction.autoStartHoldTimer = setTimeout(() => {\n          interaction.start(interaction.prepared, interaction.interactable, interaction.element)\n        }, hold)\n      }\n    },\n\n    'interactions:move': ({ interaction, duplicate }) => {\n      if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {\n        clearTimeout(interaction.autoStartHoldTimer)\n        interaction.autoStartHoldTimer = null\n      }\n    },\n\n    // prevent regular down->move autoStart\n    'autoStart:before-start': ({ interaction }) => {\n      const hold = getHoldDuration(interaction)\n\n      if (hold > 0) {\n        interaction.prepared.name = null\n      }\n    },\n  },\n  getHoldDuration,\n}\n","import * as Interact from '@interactjs/types/index'\n\nimport autoStart from './base'\nimport dragAxis from './dragAxis'\nimport hold from './hold'\n\nexport default {\n  id: 'auto-start',\n  install (scope: Interact.Scope) {\n    scope.usePlugin(autoStart)\n    scope.usePlugin(hold)\n    scope.usePlugin(dragAxis)\n  },\n}\n","export default {}\n","import * as Interact from '@interactjs/types/index'\nimport { matchesSelector, nodeContains } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    preventDefault: typeof preventDefault\n    checkAndPreventDefault: (event: Event) => void\n  }\n}\n\ntype PreventDefaultValue = 'always' | 'never' | 'auto'\nfunction preventDefault (this: Interact.Interactable): PreventDefaultValue\nfunction preventDefault (this: Interact.Interactable, newValue: PreventDefaultValue): typeof this\nfunction preventDefault (this: Interact.Interactable, newValue?: PreventDefaultValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue\n    return this\n  }\n\n  if (is.bool(newValue)) {\n    this.options.preventDefault = newValue ? 'always' : 'never'\n    return this\n  }\n\n  return this.options.preventDefault\n}\n\nfunction checkAndPreventDefault (interactable: Interact.Interactable, scope: Interact.Scope, event: Event) {\n  const setting = interactable.options.preventDefault\n\n  if (setting === 'never') { return }\n\n  if (setting === 'always') {\n    event.preventDefault()\n    return\n  }\n\n  // setting === 'auto'\n\n  // if the browser supports passive event listeners and isn't running on iOS,\n  // don't preventDefault of touch{start,move} events. CSS touch-action and\n  // user-select should be used instead of calling event.preventDefault().\n  if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {\n    const doc = getWindow(event.target).document\n    const docOptions = scope.getDocOptions(doc)\n\n    if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {\n      return\n    }\n  }\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return\n  }\n\n  // don't preventDefault on editable elements\n  if (is.element(event.target) &&\n      matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {\n    return\n  }\n\n  event.preventDefault()\n}\n\nfunction onInteractionEvent ({ interaction, event }: { interaction: Interact.Interaction, event: Interact.PointerEventType }) {\n  if (interaction.interactable) {\n    interaction.interactable.checkAndPreventDefault(event as Event)\n  }\n}\n\nexport function install (scope: Interact.Scope) {\n  /** @lends Interactable */\n  const { Interactable } = scope\n\n  /**\n   * Returns or sets whether to prevent the browser's default behaviour in\n   * response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`\n   * @return {string | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.preventDefault = preventDefault\n\n  Interactable.prototype.checkAndPreventDefault = function (event) {\n    return checkAndPreventDefault(this, scope, event)\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  scope.interactions.docEvents.push({\n    type: 'dragstart',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        if (interaction.element &&\n          (interaction.element === event.target ||\n           nodeContains(interaction.element, event.target))) {\n          interaction.interactable.checkAndPreventDefault(event)\n          return\n        }\n      }\n    },\n  })\n}\n\nexport default {\n  id: 'core/interactablePreventDefault',\n  install,\n  listeners: ['down', 'move', 'up', 'cancel'].reduce((acc, eventType) => {\n    acc[`interactions:${eventType}`] = onInteractionEvent\n    return acc\n  }, {} as any),\n}\n","/* eslint-disable no-console */\nimport * as Interact from '@interactjs/types/index'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport * as win from '@interactjs/utils/window'\n\nimport visualizer from './visualizer/plugin'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    logger: Logger\n  }\n}\n\ndeclare module '@interactjs/core/interactStatic' {\n  export interface InteractStatic {\n    visializer: typeof visualizer\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface BaseDefaults {\n    devTools?: DevToolsOptions\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    devTools: Interact.OptionMethod<DevToolsOptions>\n  }\n}\n\nexport interface DevToolsOptions {\n  ignore: { [P in keyof typeof CheckName]?: boolean }\n}\n\nexport interface Logger {\n  warn: (...args: any[]) => void\n  error: (...args: any[]) => void\n  log: (...args: any[]) => void\n}\n\nexport interface Check {\n  name: CheckName\n  text: string\n  perform: (interaction: Interact.Interaction) => boolean\n  getInfo: (interaction: Interact.Interaction) => any[]\n}\n\nenum CheckName {\n  touchAction = 'touchAction',\n  boxSizing = 'boxSizing',\n  noListeners = 'noListeners',\n}\n\nconst prefix  = '[interact.js] '\nconst links = {\n  touchAction: 'https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action',\n  boxSizing: 'https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing',\n}\n\n// eslint-disable-next-line no-undef\nconst isProduction = process.env.NODE_ENV === 'production'\n\n// eslint-disable-next-line no-restricted-syntax\nfunction install (scope: Interact.Scope, { logger }: { logger?: Logger } = {}) {\n  const {\n    Interactable,\n    defaults,\n  } = scope\n\n  scope.logger = logger || console\n\n  defaults.base.devTools = {\n    ignore: {},\n  }\n\n  Interactable.prototype.devTools = function (options?: object) {\n    if (options) {\n      extend(this.options.devTools, options)\n      return this\n    }\n\n    return this.options.devTools\n  }\n}\n\nconst checks: Check[] = [\n  {\n    name: CheckName.touchAction,\n    perform ({ element }) {\n      return !parentHasStyle(element, 'touchAction', /pan-|pinch|none/)\n    },\n    getInfo ({ element }) {\n      return [\n        element,\n        links.touchAction,\n      ]\n    },\n    text: 'Consider adding CSS \"touch-action: none\" to this element\\n',\n  },\n\n  {\n    name: CheckName.boxSizing,\n    perform (interaction) {\n      const { element } = interaction\n\n      return interaction.prepared.name === 'resize' &&\n        element instanceof domObjects.HTMLElement &&\n        !hasStyle(element, 'boxSizing', /border-box/)\n    },\n    text: 'Consider adding CSS \"box-sizing: border-box\" to this resizable element',\n    getInfo ({ element }) {\n      return [\n        element,\n        links.boxSizing,\n      ]\n    },\n  },\n\n  {\n    name: CheckName.noListeners,\n    perform (interaction) {\n      const actionName = interaction.prepared.name\n      const moveListeners = interaction.interactable.events.types[`${actionName}move`] || []\n\n      return !moveListeners.length\n    },\n    getInfo (interaction) {\n      return [\n        interaction.prepared.name,\n        interaction.interactable,\n      ]\n    },\n    text: 'There are no listeners set for this action',\n  },\n]\n\nfunction hasStyle (element: HTMLElement, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\n  const value = element.style[prop] || win.window.getComputedStyle(element)[prop]\n  return styleRe.test((value || '').toString())\n}\n\nfunction parentHasStyle (element: Interact.Element, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\n  let parent = element as HTMLElement\n\n  while (is.element(parent)) {\n    if (hasStyle(parent, prop, styleRe)) {\n      return true\n    }\n\n    parent = parentNode(parent) as HTMLElement\n  }\n\n  return false\n}\n\nconst id = 'dev-tools'\nconst defaultExport: Interact.Plugin = isProduction\n  ? { id, install: () => {} }\n  : {\n    id,\n    install,\n    listeners: {\n      'interactions:action-start': ({ interaction }, scope) => {\n        for (const check of checks) {\n          const options = interaction.interactable && interaction.interactable.options\n\n          if (\n            !(options && options.devTools && options.devTools.ignore[check.name]) &&\n            check.perform(interaction)\n          ) {\n            scope.logger.warn(prefix + check.text, ...check.getInfo(interaction))\n          }\n        }\n      },\n    },\n    checks,\n    CheckName,\n    links,\n    prefix,\n  }\n\nexport default defaultExport\n","import * as arr from './arr'\nimport is from './is'\n\n// tslint:disable-next-line ban-types\nexport default function clone<T extends Object> (source: T): Partial<T> {\n  const dest = {} as Partial<T>\n\n  for (const prop in source) {\n    const value = source[prop]\n\n    if (is.plainObject(value)) {\n      dest[prop] = clone(value) as any\n    }\n    else if (is.array(value)) {\n      dest[prop] = arr.from(value) as typeof value\n    }\n    else {\n      dest[prop] = value\n    }\n  }\n\n  return dest\n}\n","import * as Interact from '@interactjs/types/index'\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { Modifier, ModifierArg, ModifierState } from './base'\n\nexport interface ModificationResult {\n  delta: Interact.Point\n  rectDelta: Interact.Rect\n  coords: Interact.Point\n  rect: Interact.FullRect\n  eventProps: any[]\n  changed: boolean\n}\n\ninterface MethodArg {\n  phase: Interact.EventPhase\n  pageCoords?: Interact.Point\n  rect?: Interact.FullRect\n  coords?: Interact.Point\n  preEnd?: boolean\n  skipModifiers?: number\n}\n\nexport default class Modification {\n  states: ModifierState[] = []\n  startOffset: Interact.Rect = { left: 0, right: 0, top: 0, bottom: 0 }\n  startDelta: Interact.Point = null\n  result?: ModificationResult = null\n  endResult?: Interact.Point = null\n  edges: Interact.EdgeOptions\n  readonly interaction: Readonly<Interact.Interaction>\n\n  constructor (interaction: Interact.Interaction) {\n    this.interaction = interaction\n    this.result = createResult()\n  }\n\n  start (\n    { phase }: MethodArg,\n    pageCoords: Interact.Point,\n  ) {\n    const { interaction } = this\n    const modifierList = getModifierList(interaction)\n    this.prepareStates(modifierList)\n\n    this.edges = extend({}, interaction.edges)\n    this.startOffset = getRectOffset(interaction.rect, pageCoords)\n    this.startDelta = { x: 0, y: 0 }\n\n    const arg: MethodArg = {\n      phase,\n      pageCoords,\n      preEnd: false,\n    }\n\n    this.result = createResult()\n    this.startAll(arg)\n\n    const result = this.result = this.setAll(arg)\n\n    return result\n  }\n\n  fillArg (arg: Partial<ModifierArg>) {\n    const { interaction } = this\n\n    arg.interaction = interaction\n    arg.interactable = interaction.interactable\n    arg.element = interaction.element\n    arg.rect = arg.rect || interaction.rect\n    arg.edges = this.edges\n    arg.startOffset = this.startOffset\n  }\n\n  startAll (arg: MethodArg & Partial<ModifierArg>) {\n    this.fillArg(arg)\n\n    for (const state of this.states) {\n      if (state.methods.start) {\n        arg.state = state\n        state.methods.start(arg as ModifierArg)\n      }\n    }\n  }\n\n  setAll (arg: MethodArg & Partial<ModifierArg>): ModificationResult {\n    this.fillArg(arg)\n\n    const {\n      phase,\n      preEnd,\n      skipModifiers,\n      rect: unmodifiedRect,\n    } = arg\n\n    arg.coords = extend({}, arg.pageCoords)\n    arg.rect = extend({}, unmodifiedRect)\n\n    const states = skipModifiers\n      ? this.states.slice(skipModifiers)\n      : this.states\n\n    const newResult = createResult(arg.coords, arg.rect)\n\n    for (const state of states) {\n      const { options } = state\n      const lastModifierCoords = extend({}, arg.coords)\n      let returnValue = null\n\n      if (state.methods.set && this.shouldDo(options, preEnd, phase)) {\n        arg.state = state\n        returnValue = state.methods.set(arg as ModifierArg)\n\n        rectUtils.addEdges(this.interaction.edges, arg.rect, { x: arg.coords.x - lastModifierCoords.x, y: arg.coords.y - lastModifierCoords.y })\n      }\n\n      newResult.eventProps.push(returnValue)\n    }\n\n    newResult.delta.x = arg.coords.x - arg.pageCoords.x\n    newResult.delta.y = arg.coords.y - arg.pageCoords.y\n\n    newResult.rectDelta.left   = arg.rect.left - unmodifiedRect.left\n    newResult.rectDelta.right  = arg.rect.right - unmodifiedRect.right\n    newResult.rectDelta.top    = arg.rect.top - unmodifiedRect.top\n    newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom\n\n    const prevCoords = this.result.coords\n    const prevRect = this.result.rect\n\n    if (prevCoords && prevRect) {\n      const rectChanged = newResult.rect.left !== prevRect.left ||\n        newResult.rect.right !== prevRect.right ||\n        newResult.rect.top !== prevRect.top ||\n        newResult.rect.bottom !== prevRect.bottom\n\n      newResult.changed = rectChanged ||\n        prevCoords.x !== newResult.coords.x ||\n        prevCoords.y !== newResult.coords.y\n    }\n\n    return newResult\n  }\n\n  applyToInteraction (arg: { phase: Interact.EventPhase, rect?: Interact.Rect }) {\n    const { interaction } = this\n    const { phase } = arg\n    const curCoords = interaction.coords.cur\n    const startCoords = interaction.coords.start\n    const { result, startDelta } = this\n    const curDelta = result.delta\n\n    if (phase === 'start') {\n      extend(this.startDelta, result.delta)\n    }\n\n    for (const [coordsSet, delta] of [[startCoords, startDelta], [curCoords, curDelta]] as const) {\n      coordsSet.page.x   += delta.x\n      coordsSet.page.y   += delta.y\n      coordsSet.client.x += delta.x\n      coordsSet.client.y += delta.y\n    }\n\n    const { rectDelta } = this.result\n    const rect = arg.rect || interaction.rect\n\n    rect.left   += rectDelta.left\n    rect.right  += rectDelta.right\n    rect.top    += rectDelta.top\n    rect.bottom += rectDelta.bottom\n\n    rect.width = rect.right - rect.left\n    rect.height = rect.bottom - rect.top\n  }\n\n  setAndApply (arg: Partial<Interact.DoAnyPhaseArg> & {\n    phase: Interact.EventPhase\n    preEnd?: boolean\n    skipModifiers?: number\n    modifiedCoords?: Interact.Point\n  }): void | false {\n    const { interaction } = this\n    const { phase, preEnd, skipModifiers } = arg\n\n    const result = this.setAll({\n      preEnd,\n      phase,\n      pageCoords: arg.modifiedCoords || interaction.coords.cur.page,\n    })\n\n    this.result = result\n\n    // don't fire an action move if a modifier would keep the event in the same\n    // cordinates as before\n    if (!result.changed && (!skipModifiers || skipModifiers < this.states.length) && interaction.interacting()) {\n      return false\n    }\n\n    if (arg.modifiedCoords) {\n      const { page } = interaction.coords.cur\n      const adjustment = {\n        x: arg.modifiedCoords.x - page.x,\n        y: arg.modifiedCoords.y - page.y,\n      }\n\n      result.coords.x += adjustment.x\n      result.coords.y += adjustment.y\n      result.delta.x += adjustment.x\n      result.delta.y += adjustment.y\n    }\n\n    this.applyToInteraction(arg)\n  }\n\n  beforeEnd (arg: Omit<Interact.DoAnyPhaseArg, 'iEvent'> & { state?: ModifierState }): void | false {\n    const { interaction, event } = arg\n    const states = this.states\n\n    if (!states || !states.length) {\n      return\n    }\n\n    let doPreend = false\n\n    for (const state of states) {\n      arg.state = state\n      const { options, methods } = state\n\n      const endPosition = methods.beforeEnd && methods.beforeEnd(arg as unknown as ModifierArg)\n\n      if (endPosition) {\n        this.endResult = endPosition\n        return false\n      }\n\n      doPreend = doPreend || (!doPreend && this.shouldDo(options, true, arg.phase, true))\n    }\n\n    if (doPreend) {\n      // trigger a final modified move before ending\n      interaction.move({ event, preEnd: true })\n    }\n  }\n\n  stop (arg: { interaction: Interact.Interaction }) {\n    const { interaction } = arg\n\n    if (!this.states || !this.states.length) {\n      return\n    }\n\n    const modifierArg: Partial<ModifierArg> = extend({\n      states: this.states,\n      interactable: interaction.interactable,\n      element: interaction.element,\n      rect: null,\n    }, arg)\n\n    this.fillArg(modifierArg)\n\n    for (const state of this.states) {\n      modifierArg.state = state\n\n      if (state.methods.stop) { state.methods.stop(modifierArg as ModifierArg) }\n    }\n\n    this.states = null\n    this.endResult = null\n  }\n\n  prepareStates (modifierList: Modifier[]) {\n    this.states = []\n\n    for (let index = 0; index < modifierList.length; index++) {\n      const { options, methods, name } = modifierList[index]\n\n      this.states.push({\n        options,\n        methods,\n        index,\n        name,\n      })\n    }\n\n    return this.states\n  }\n\n  restoreInteractionCoords ({ interaction: { coords, rect, modification } }: { interaction: Interact.Interaction }) {\n    if (!modification.result) { return }\n\n    const { startDelta } = modification\n    const { delta: curDelta, rectDelta } = modification.result\n\n    const coordsAndDeltas = [\n      [coords.start, startDelta],\n      [coords.cur, curDelta],\n    ]\n\n    for (const [coordsSet, delta] of coordsAndDeltas as any) {\n      coordsSet.page.x -= delta.x\n      coordsSet.page.y -= delta.y\n      coordsSet.client.x -= delta.x\n      coordsSet.client.y -= delta.y\n    }\n\n    rect.left -= rectDelta.left\n    rect.right -= rectDelta.right\n    rect.top -= rectDelta.top\n    rect.bottom -= rectDelta.bottom\n  }\n\n  shouldDo (options, preEnd?: boolean, phase?: string, requireEndOnly?: boolean) {\n    if (\n      // ignore disabled modifiers\n      (!options || options.enabled === false) ||\n      // check if we require endOnly option to fire move before end\n      (requireEndOnly && !options.endOnly) ||\n      // don't apply endOnly modifiers when not ending\n      (options.endOnly && !preEnd) ||\n      // check if modifier should run be applied on start\n      (phase === 'start' && !options.setStart)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  copyFrom (other: Modification) {\n    this.startOffset = other.startOffset\n    this.startDelta = other.startDelta\n    this.edges = other.edges\n    this.states = other.states.map(s => clone(s) as ModifierState)\n    this.result = createResult(extend({}, other.result.coords), extend({}, other.result.rect))\n  }\n\n  destroy () {\n    for (const prop in this) {\n      this[prop] = null\n    }\n  }\n}\n\nfunction createResult (coords?: Interact.Point, rect?: Interact.FullRect): ModificationResult {\n  return {\n    rect,\n    coords,\n    delta: { x: 0, y: 0 },\n    rectDelta: {\n      left  : 0,\n      right : 0,\n      top   : 0,\n      bottom: 0,\n    },\n    eventProps: [],\n    changed: true,\n  }\n}\n\nfunction getModifierList (interaction) {\n  const actionOptions = interaction.interactable.options[interaction.prepared.name]\n  const actionModifiers = actionOptions.modifiers\n\n  if (actionModifiers && actionModifiers.length) {\n    return actionModifiers\n  }\n\n  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize']\n    .map(type => {\n      const options = actionOptions[type]\n\n      return options && options.enabled && {\n        options,\n        methods: options._methods,\n      }\n    })\n    .filter(m => !!m)\n}\n\nexport function getRectOffset (rect, coords) {\n  return rect\n    ? {\n      left  : coords.x - rect.left,\n      top   : coords.y - rect.top,\n      right : rect.right  - coords.x,\n      bottom: rect.bottom - coords.y,\n    }\n    : {\n      left  : 0,\n      top   : 0,\n      right : 0,\n      bottom: 0,\n    }\n}\n","import * as Interact from '@interactjs/types/index'\n\nimport Modification from './Modification'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    modification?: Modification\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    modifiers?: Array<{\n      name: string\n      [key: string]: any\n    }>\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    modifiers?: Modifier[]\n  }\n}\n\nexport interface Modifier<\n  Defaults = any,\n  State extends ModifierState = any,\n  Name extends string = any\n> {\n  options?: Defaults\n  methods: {\n    start?: (arg: ModifierArg<State>) => void\n    set: (arg: ModifierArg<State>) => void\n    beforeEnd?: (arg: ModifierArg<State>) => Interact.Point | void\n    stop?: (arg: ModifierArg<State>) => void\n  }\n  name?: Name\n  enable: () => Modifier<Defaults, State, Name>\n  disable: () => Modifier<Defaults, State, Name>\n}\n\nexport type ModifierState<\n  Defaults = {},\n  StateProps extends { [prop: string]: any } = {},\n  Name extends string = any\n> = {\n  options: Defaults\n  methods?: Modifier<Defaults>['methods']\n  index?: number\n  name?: Name\n} & StateProps\n\nexport interface ModifierArg<State extends ModifierState = ModifierState> {\n  interaction: Interact.Interaction\n  interactable: Interact.Interactable\n  phase: Interact.EventPhase\n  rect: Interact.FullRect\n  edges: Interact.EdgeOptions\n  state?: State\n  element: Interact.Element\n  pageCoords?: Interact.Point\n  prevCoords?: Interact.Point\n  prevRect?: Interact.FullRect\n  coords?: Interact.Point\n  startOffset?: Interact.Rect\n  preEnd?: boolean\n}\n\nexport interface ModifierModule<\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n> {\n  defaults?: Defaults\n  start? (arg: ModifierArg<State>): void\n  set? (arg: ModifierArg<State>): any\n  beforeEnd? (arg: ModifierArg<State>): Interact.Point | void\n  stop? (arg: ModifierArg<State>): void\n}\n\nexport interface ModifierFunction <\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Name extends string,\n> {\n  (_options?: Partial<Defaults>): Modifier<Defaults, State, Name>\n  _defaults: Defaults\n  _methods: ModifierModule<Defaults, State>\n}\n\nexport function makeModifier<\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Name extends string\n> (\n  module: ModifierModule<Defaults, State>,\n  name?: Name,\n) {\n  const { defaults } = module\n  const methods = {\n    start: module.start,\n    set: module.set,\n    beforeEnd: module.beforeEnd,\n    stop: module.stop,\n  }\n\n  const modifier = (_options?: Partial<Defaults>) => {\n    const options: Defaults = (_options || {}) as Defaults\n\n    options.enabled = options.enabled !== false\n\n    // add missing defaults to options\n    for (const prop in defaults) {\n      if (!(prop in options)) {\n        options[prop] = defaults[prop]\n      }\n    }\n\n    const m: Modifier<Defaults, State, Name> = {\n      options,\n      methods,\n      name,\n      enable: () => {\n        options.enabled = true\n        return m\n      },\n      disable: () => {\n        options.enabled = false\n        return m\n      },\n    }\n\n    return m\n  }\n\n  if (name && typeof name === 'string') {\n    // for backwrads compatibility\n    modifier._defaults = defaults\n    modifier._methods = methods\n  }\n\n  return modifier\n}\n\nexport function addEventModifiers ({ iEvent, interaction: { modification: { result } } }: {\n  iEvent: Interact.InteractEvent<Interact.ActionName, Interact.EventPhase>\n  interaction: Interact.Interaction\n}) {\n  if (result) {\n    iEvent.modifiers = result.eventProps\n  }\n}\n\nconst modifiersBase: Interact.Plugin = {\n  id: 'modifiers/base',\n  before: ['actions'],\n  install: scope => {\n    scope.defaults.perAction.modifiers = []\n  },\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.modification = new Modification(interaction)\n    },\n\n    'interactions:before-action-start': arg => {\n      const { modification } = arg.interaction\n\n      modification.start(arg, arg.interaction.coords.start.page)\n      arg.interaction.edges = modification.edges\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-move': arg => arg.interaction.modification.setAndApply(arg),\n\n    'interactions:before-action-end': arg => arg.interaction.modification.beforeEnd(arg),\n\n    'interactions:action-start': addEventModifiers,\n    'interactions:action-move': addEventModifiers,\n    'interactions:action-end': addEventModifiers,\n\n    'interactions:after-action-start': arg => arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-move': arg => arg.interaction.modification.restoreInteractionCoords(arg),\n\n    'interactions:stop': arg => arg.interaction.modification.stop(arg),\n  },\n}\n\nexport default modifiersBase\n","import * as Interact from '@interactjs/types/index'\n\nexport interface Defaults {\n  base: BaseDefaults\n  perAction: PerActionDefaults\n  actions: ActionDefaults\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionDefaults {\n}\n\nexport interface BaseDefaults {\n  preventDefault?: 'auto' | 'never' | string\n  deltaSource?: 'page' | 'client'\n  context?: Node\n}\n\nexport interface PerActionDefaults {\n  enabled?: boolean\n  origin?: Interact.Point | string | Interact.Element\n  listeners?: Interact.Listeners\n  allowFrom?: string | Interact.Element\n  ignoreFrom?: string | Interact.Element\n}\n\nexport type Options = Partial<BaseDefaults> & Partial<PerActionDefaults> & {\n  [P in keyof ActionDefaults]?: Partial<ActionDefaults[P]>\n}\n\n// export interface Options extends BaseDefaults, PerActionDefaults {}\n\nexport interface OptionsArg extends BaseDefaults, Interact.OrBoolean<Partial<ActionDefaults>> {}\n\nexport const defaults: Defaults = {\n  base: {\n    preventDefault: 'auto',\n    deltaSource: 'page',\n  },\n\n  perAction: {\n    enabled: false,\n    origin: { x: 0, y: 0 },\n  },\n\n  actions: {} as ActionDefaults,\n}\n","import * as Interact from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\n\nimport { BaseEvent } from './BaseEvent'\nimport { Interaction } from './Interaction'\nimport { defaults } from './defaultOptions'\n\nexport type EventPhase = keyof PhaseMap\n\nexport interface PhaseMap {\n  start: true\n  move: true\n  end: true\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface InteractEvent {\n  pageX: number\n  pageY: number\n\n  clientX: number\n  clientY: number\n\n  dx: number\n  dy: number\n\n  velocityX: number\n  velocityY: number\n}\n\nexport class InteractEvent<\n  T extends Interact.ActionName = never,\n  P extends EventPhase = EventPhase,\n> extends BaseEvent<T> {\n  target: Interact.Element\n  currentTarget: Interact.Element\n  relatedTarget: null = null\n  screenX?: number\n  screenY?: number\n  button: number\n  buttons: number\n  ctrlKey: boolean\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  page: Interact.Point\n  client: Interact.Point\n  delta: Interact.Point\n  rect: Interact.FullRect\n  x0: number\n  y0: number\n  t0: number\n  dt: number\n  duration: number\n  clientX0: number\n  clientY0: number\n  velocity: Interact.Point\n  speed: number\n  swipe: ReturnType<InteractEvent<T>['getSwipe']>\n  timeStamp: any\n  // drag\n  dragEnter?: Interact.Element\n  dragLeave?: Interact.Element\n  // resize\n  axes?: 'x' | 'y' | 'xy'\n  preEnd?: boolean\n\n  /** */\n  constructor (\n    interaction: Interaction,\n    event: Interact.PointerEventType,\n    actionName: T,\n    phase: P,\n    element: Interact.Element,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    super(interaction)\n\n    element = element || interaction.element\n\n    const target      = interaction.interactable\n    const deltaSource = (((target && target.options) || defaults) as any).deltaSource as 'page' | 'client'\n    const origin      = getOriginXY(target, element, actionName)\n    const starting    = phase === 'start'\n    const ending      = phase === 'end'\n    const prevEvent   = starting ? this : interaction.prevEvent\n    const coords      = starting\n      ? interaction.coords.start\n      : ending\n        ? { page: prevEvent.page, client: prevEvent.client, timeStamp: interaction.coords.cur.timeStamp }\n        : interaction.coords.cur\n\n    this.page      = extend({}, coords.page)\n    this.client    = extend({}, coords.client)\n    this.rect      = extend({}, interaction.rect)\n    this.timeStamp = coords.timeStamp\n\n    if (!ending) {\n      this.page.x -= origin.x\n      this.page.y -= origin.y\n\n      this.client.x -= origin.x\n      this.client.y -= origin.y\n    }\n\n    this.ctrlKey       = event.ctrlKey\n    this.altKey        = event.altKey\n    this.shiftKey      = event.shiftKey\n    this.metaKey       = event.metaKey\n    this.button        = (event as MouseEvent).button\n    this.buttons       = (event as MouseEvent).buttons\n    this.target        = element\n    this.currentTarget = element\n    this.preEnd        = preEnd\n    this.type          = type || (actionName + (phase || ''))\n    this.interactable  = target\n\n    this.t0 = starting\n      ? interaction.pointers[interaction.pointers.length - 1].downTime\n      : prevEvent.t0\n\n    this.x0       = interaction.coords.start.page.x - origin.x\n    this.y0       = interaction.coords.start.page.y - origin.y\n    this.clientX0 = interaction.coords.start.client.x - origin.x\n    this.clientY0 = interaction.coords.start.client.y - origin.y\n\n    if (starting || ending) {\n      this.delta = { x: 0, y: 0 }\n    }\n    else {\n      this.delta = {\n        x: this[deltaSource].x - prevEvent[deltaSource].x,\n        y: this[deltaSource].y - prevEvent[deltaSource].y,\n      }\n    }\n\n    this.dt        = interaction.coords.delta.timeStamp\n    this.duration  = this.timeStamp - this.t0\n\n    // velocity and speed in pixels per second\n    this.velocity = extend({}, interaction.coords.velocity[deltaSource])\n    this.speed = hypot(this.velocity.x, this.velocity.y)\n\n    this.swipe = (ending || phase === 'inertiastart') ? this.getSwipe() : null\n  }\n\n  getSwipe () {\n    const interaction = this._interaction\n\n    if (interaction.prevEvent.speed < 600 ||\n        this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null\n    }\n\n    let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI\n    const overlap = 22.5\n\n    if (angle < 0) {\n      angle += 360\n    }\n\n    const left = 135 - overlap <= angle && angle < 225 + overlap\n    const up   = 225 - overlap <= angle && angle < 315 + overlap\n\n    const right = !left && (315 - overlap <= angle || angle <  45 + overlap)\n    const down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    }\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperties(InteractEvent.prototype, {\n  pageX: { get () { return this.page.x }, set (value) { this.page.x = value } },\n  pageY: { get () { return this.page.y }, set (value) { this.page.y = value } },\n\n  clientX: { get () { return this.client.x }, set (value) { this.client.x = value } },\n  clientY: { get () { return this.client.y }, set (value) { this.client.y = value } },\n\n  dx: { get () { return this.delta.x }, set (value) { this.delta.x = value } },\n  dy: { get () { return this.delta.y }, set (value) { this.delta.y = value } },\n\n  velocityX: { get () { return this.velocity.x }, set (value) { this.velocity.x = value } },\n  velocityY: { get () { return this.velocity.y }, set (value) { this.velocity.y = value } },\n\n})\n","import * as Interact from '@interactjs/types/index'\n\nexport class PointerInfo {\n  id: number\n  pointer: Interact.PointerType\n  event: Interact.PointerEventType\n  downTime: number\n  downTarget: Node\n\n  constructor (\n    id: number,\n    pointer: Interact.PointerType,\n    event: Interact.PointerEventType,\n    downTime: number,\n    downTarget: Node,\n  ) {\n    this.id = id\n    this.pointer = pointer\n    this.event = event\n    this.downTime = downTime\n    this.downTarget = downTarget\n  }\n}\n","import * as Interact from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport hypot from '@interactjs/utils/hypot'\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { InteractEvent, EventPhase } from './InteractEvent'\nimport { Interactable } from './Interactable'\nimport { PointerInfo } from './PointerInfo'\nimport { ActionName } from './scope'\n\nexport interface ActionProps<T extends ActionName = Interact.ActionName> {\n  name: T\n  axis?: 'x' | 'y' | 'xy'\n  edges?: Interact.EdgeOptions\n}\n\nexport interface StartAction extends ActionProps {\n  name: ActionName\n}\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = ''\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = ''\n}\n\nexport type PointerArgProps<T extends {} = {}> = {\n  pointer: Interact.PointerType\n  event: Interact.PointerEventType\n  eventTarget: Node\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction\n} & T\n\nexport interface DoPhaseArg<T extends ActionName, P extends EventPhase> {\n  event: Interact.PointerEventType\n  phase: EventPhase\n  interaction: Interaction<T>\n  iEvent: InteractEvent<T, P>\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg<ActionName, EventPhase>\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction }\n    'interactions:down': PointerArgProps<{\n      type: 'down'\n    }>\n    'interactions:move': PointerArgProps<{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }>\n    'interactions:up': PointerArgProps<{\n      type: 'up'\n      curEventTarget: EventTarget\n    }>\n    'interactions:cancel': SignalArgs['interactions:up'] & {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps<{\n      down: boolean\n    }>\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur': { interaction: Interaction, event: Event, type: 'blur' }\n    'interactions:before-action-start': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy<T extends ActionName = ActionName> = Pick<\nInteraction<T>,\nkeyof typeof _ProxyValues | keyof typeof _ProxyMethods\n>\n\nlet idCounter = 0\n\nexport class Interaction<T extends ActionName = ActionName> {\n  // current interactable being interacted with\n  interactable: Interactable = null\n\n  // the target element of the interactable\n  element: Interact.Element = null\n  rect: Interact.FullRect\n  _rects?: {\n    start: Interact.FullRect\n    corrected: Interact.FullRect\n    previous: Interact.FullRect\n    delta: Interact.FullRect\n  }\n  edges: Interact.EdgeOptions\n\n  _scopeFire: Interact.Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps<T> = {\n    name : null,\n    axis : null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  // keep track of added pointers\n  pointers: PointerInfo[] = []\n\n  // pointerdown/mousedown/touchstart event\n  downEvent: Interact.PointerEventType = null\n\n  downPointer: Interact.PointerType = {} as Interact.PointerType\n\n  _latestPointer: {\n    pointer: Interact.PointerType\n    event: Interact.PointerEventType\n    eventTarget: Node\n  } = {\n    pointer: null,\n    event: null,\n    eventTarget: null,\n  }\n\n  // previous action event\n  prevEvent: InteractEvent<T, EventPhase> = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  _interacting = false\n  _ending = false\n  _stopped = true\n  _proxy: InteractionProxy<T> = null\n\n  simulation = null\n\n  /** @internal */ get pointerMoveTolerance () {\n    return 1\n  }\n\n  /**\n   * @alias Interaction.prototype.move\n   */\n  doMove = warnOnce(\n    function (this: Interaction, signalArg: any) {\n      this.move(signalArg)\n    },\n    'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: Interact.CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: pointerUtils.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: pointerUtils.newCoords(),\n    // current native pointer move event coordinates\n    cur: pointerUtils.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: pointerUtils.newCoords(),\n    // pointer velocity\n    velocity: pointerUtils.newCoords(),\n  }\n\n  readonly _id: number = idCounter++\n\n  /** */\n  constructor ({ pointerType, scopeFire }: {\n    pointerType?: string\n    scopeFire: Interact.Scope['fire']\n  }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy<T>\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get () { return that[key] },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args: any[]) => that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: Node) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: this,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {Boolean} Whether the interaction was successfully started\n   */\n  start (action: StartAction, interactable: Interactable, element: Interact.Element): boolean {\n    if (this.interacting() ||\n        !this.pointerIsDown ||\n        this.pointers.length < (action.name === 'gesture' ? 2 : 1) ||\n        !interactable.options[action.name].enabled) {\n      return false\n    }\n\n    copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element      = element\n    this.rect         = interactable.getRect(element)\n    this.edges        = this.prepared.edges\n      ? extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped     = false\n    this._interacting = this._doPhase({\n      interaction: this,\n      event: this.downEvent,\n      phase: 'start',\n    }) && !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: Node) {\n    if (!this.simulation && !(this.modification && this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove = (this.coords.cur.page.x === this.coords.prev.page.x &&\n                           this.coords.cur.page.y === this.coords.prev.page.y &&\n                           this.coords.cur.client.x === this.coords.prev.client.x &&\n                           this.coords.cur.client.y === this.coords.prev.client.y)\n\n    let dx: number\n    let dy: number\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove && !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move (signalArg?: any) {\n    if (!signalArg || !signalArg.event) {\n      pointerUtils.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = extend({\n      pointer: this._latestPointer.pointer,\n      event: this._latestPointer.event,\n      eventTarget: this._latestPointer.eventTarget,\n      interaction: this,\n    }, signalArg || {})\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: Node, curEventTarget: Interact.EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: this,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.removePointer(pointer, event)\n  }\n\n  documentBlur (event: Event) {\n    this.end(event as any)\n    this._scopeFire('interactions:blur', { event, type: 'blur', interaction: this })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event?: Interact.PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult: boolean\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction () {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting () {\n    return this._interacting\n  }\n\n  /** */\n  stop () {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  getPointerIndex (pointer: Interact.PointerType) {\n    const pointerId = pointerUtils.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return (this.pointerType === 'mouse' || this.pointerType === 'pen')\n      ? this.pointers.length - 1\n      : arr.findIndex(this.pointers, curPointer => curPointer.id === pointerId)\n  }\n\n  getPointerInfo (pointer: any) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  updatePointer (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: Node, down?: boolean) {\n    const id = pointerUtils.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false\n      ? false\n      : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(\n        id,\n        pointer,\n        event,\n        null,\n        null,\n      )\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    }\n    else {\n      pointerInfo.pointer = pointer\n    }\n\n    pointerUtils.setCoords(this.coords.cur, this.pointers.map(p => p.pointer), this._now())\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      pointerUtils.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: this,\n    })\n\n    return pointerIndex\n  }\n\n  removePointer (pointer: Interact.PointerType, event: Interact.PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) { return }\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: this,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n    this.pointerIsDown = false\n  }\n\n  _updateLatestPointer (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: Node) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy () {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  _createPreparedEvent<P extends EventPhase> (event: Interact.PointerEventType, phase: P, preEnd?: boolean, type?: string) {\n    return new InteractEvent<T, P>(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  _fireEvent<P extends EventPhase> (iEvent: InteractEvent<T, P>) {\n    this.interactable.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  _doPhase<P extends EventPhase> (signalArg: Omit<DoPhaseArg<T, P>, 'iEvent'> & { iEvent?: InteractEvent<T, P> }) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect && phase === 'move') {\n      // update the rect changes due to pointer move\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type)\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') { this.prevEvent = iEvent }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  _now () { return Date.now() }\n}\n\nexport default Interaction\nexport { PointerInfo }\n","import { _ProxyMethods } from '@interactjs/core/Interaction'\nimport * as Interact from '@interactjs/types/index'\nimport * as rectUtils from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    offsetBy?: typeof offsetBy\n    offset: {\n      total: Interact.Point\n      pending: Interact.Point\n    }\n  }\n\n  // eslint-disable-next-line no-shadow\n  enum _ProxyMethods {\n    // eslint-disable-next-line no-shadow\n    offsetBy = ''\n  }\n}\n\n(_ProxyMethods as any).offsetBy = ''\n\nexport function addTotal (interaction: Interact.Interaction) {\n  if (!interaction.pointerIsDown) { return }\n\n  addToCoords(interaction.coords.cur, interaction.offset.total)\n\n  interaction.offset.pending.x = 0\n  interaction.offset.pending.y = 0\n}\n\nfunction beforeAction ({ interaction }: { interaction: Interact.Interaction }) {\n  applyPending(interaction)\n}\n\nfunction beforeEnd ({ interaction }: { interaction: Interact.Interaction }): boolean | void {\n  const hadPending = applyPending(interaction)\n\n  if (!hadPending) { return }\n\n  interaction.move({ offset: true })\n  interaction.end()\n\n  return false\n}\n\nfunction end ({ interaction }: { interaction: Interact.Interaction }) {\n  interaction.offset.total.x = 0\n  interaction.offset.total.y = 0\n  interaction.offset.pending.x = 0\n  interaction.offset.pending.y = 0\n}\n\nexport function applyPending (interaction: Interact.Interaction) {\n  if (!hasPending(interaction)) {\n    return false\n  }\n\n  const { pending } = interaction.offset\n\n  addToCoords(interaction.coords.cur, pending)\n  addToCoords(interaction.coords.delta, pending)\n  rectUtils.addEdges(interaction.edges, interaction.rect, pending)\n\n  pending.x = 0\n  pending.y = 0\n\n  return true\n}\n\nfunction offsetBy (this: Interact.Interaction, { x, y }: Interact.Point) {\n  this.offset.pending.x += x\n  this.offset.pending.y += y\n\n  this.offset.total.x += x\n  this.offset.total.y += y\n}\n\nfunction addToCoords ({ page, client }, { x, y }: Interact.Point) {\n  page.x += x\n  page.y += y\n  client.x += x\n  client.y += y\n}\n\nfunction hasPending (interaction) {\n  return !!(interaction.offset.pending.x || interaction.offset.pending.y)\n}\n\nconst offset: Interact.Plugin = {\n  id: 'offset',\n  before: ['modifiers', 'pointer-events', 'actions', 'inertia'],\n  install (scope) {\n    scope.Interaction.prototype.offsetBy = offsetBy\n  },\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.offset = {\n        total: { x: 0, y: 0 },\n        pending: { x: 0, y: 0 },\n      }\n    },\n    'interactions:update-pointer': ({ interaction }) => addTotal(interaction),\n    'interactions:before-action-start': beforeAction,\n    'interactions:before-action-move': beforeAction,\n    'interactions:before-action-end': beforeEnd,\n    'interactions:stop': end,\n  },\n}\n\nexport default offset\n","import Modification from '@interactjs/modifiers/Modification'\nimport * as modifiers from '@interactjs/modifiers/base'\nimport offset from '@interactjs/offset/plugin'\nimport * as Interact from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { copyCoords } from '@interactjs/utils/pointerUtils'\nimport raf from '@interactjs/utils/raf'\n\ndeclare module '@interactjs/core/InteractEvent' {\n  // eslint-disable-next-line no-shadow\n  interface PhaseMap {\n    resume?: true\n    inertiastart?: true\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    inertia?: InertiaState\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface PerActionDefaults {\n    inertia?: {\n      enabled?: boolean\n      resistance?: number        // the lambda in exponential decay\n      minSpeed?: number          // target speed must be above this for inertia to start\n      endSpeed?: number          // the speed at which inertia is slow enough to stop\n      allowResume?: true         // allow resuming an action in inertia phase\n      smoothEndDuration?: number // animate to snap/restrict endOnly if there's no inertia\n    }\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-inertiastart': Omit<Interact.DoPhaseArg<Interact.ActionName, 'inertiastart'>, 'iEvent'>\n    'interactions:action-inertiastart': Interact.DoPhaseArg<Interact.ActionName, 'inertiastart'>\n    'interactions:after-action-inertiastart': Interact.DoPhaseArg<Interact.ActionName, 'inertiastart'>\n    'interactions:before-action-resume': Omit<Interact.DoPhaseArg<Interact.ActionName, 'resume'>, 'iEvent'>\n    'interactions:action-resume': Interact.DoPhaseArg<Interact.ActionName, 'resume'>\n    'interactions:after-action-resume': Interact.DoPhaseArg<Interact.ActionName, 'resume'>\n  }\n}\n\nfunction install (scope: Interact.Scope) {\n  const {\n    defaults,\n  } = scope\n\n  scope.usePlugin(offset)\n  scope.usePlugin(modifiers.default)\n  scope.actions.phases.inertiastart = true\n  scope.actions.phases.resume = true\n\n  defaults.perAction.inertia = {\n    enabled          : false,\n    resistance       : 10,    // the lambda in exponential decay\n    minSpeed         : 100,   // target speed must be above this for inertia to start\n    endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n    allowResume      : true,  // allow resuming an action in inertia phase\n    smoothEndDuration: 300,   // animate to snap/restrict endOnly if there's no inertia\n  }\n}\n\nexport class InertiaState {\n  active = false\n  isModified = false\n  smoothEnd = false\n  allowResume = false\n\n  modification: Modification = null\n  modifierCount = 0\n  modifierArg: modifiers.ModifierArg = null\n\n  startCoords: Interact.Point = null\n  t0 = 0\n  v0 = 0\n\n  te = 0\n  targetOffset: Interact.Point = null\n  modifiedOffset: Interact.Point = null\n  currentOffset: Interact.Point = null\n\n  lambda_v0? = 0 // eslint-disable-line camelcase\n  one_ve_v0? = 0 // eslint-disable-line camelcase\n  timeout: number = null\n  readonly interaction: Interact.Interaction\n\n  constructor (interaction: Interact.Interaction) {\n    this.interaction = interaction\n  }\n\n  start (event: Interact.PointerEventType) {\n    const { interaction } = this\n    const options = getOptions(interaction)\n\n    if (!options || !options.enabled) {\n      return false\n    }\n\n    const { client: velocityClient } = interaction.coords.velocity\n    const pointerSpeed = hypot(velocityClient.x, velocityClient.y)\n    const modification = this.modification || (this.modification = new Modification(interaction))\n\n    modification.copyFrom(interaction.modification)\n\n    this.t0 = interaction._now()\n    this.allowResume = options.allowResume\n    this.v0 = pointerSpeed\n    this.currentOffset = { x: 0, y: 0 }\n    this.startCoords = interaction.coords.cur.page\n\n    this.modifierArg = {\n      interaction,\n      interactable: interaction.interactable,\n      element: interaction.element,\n      rect: interaction.rect,\n      edges: interaction.edges,\n      pageCoords: this.startCoords,\n      preEnd: true,\n      phase: 'inertiastart',\n    }\n\n    const thrown = (\n      (this.t0 - interaction.coords.cur.timeStamp) < 50 &&\n      pointerSpeed > options.minSpeed &&\n      pointerSpeed > options.endSpeed\n    )\n\n    if (thrown) {\n      this.startInertia()\n    } else {\n      modification.result = modification.setAll(this.modifierArg)\n\n      if (!modification.result.changed) {\n        return false\n      }\n\n      this.startSmoothEnd()\n    }\n\n    // force modification change\n    interaction.modification.result.rect = null\n\n    // bring inertiastart event to the target coords\n    interaction.offsetBy(this.targetOffset)\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'inertiastart',\n    })\n    interaction.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y })\n    // force modification change\n    interaction.modification.result.rect = null\n\n    this.active = true\n    interaction.simulation = this\n\n    return true\n  }\n\n  startInertia () {\n    const startVelocity = this.interaction.coords.velocity.client\n    const options = getOptions(this.interaction)\n    const lambda = options.resistance\n    const inertiaDur = -Math.log(options.endSpeed / this.v0) / lambda\n\n    this.targetOffset = {\n      x: (startVelocity.x - inertiaDur) / lambda,\n      y: (startVelocity.y - inertiaDur) / lambda,\n    }\n\n    this.te = inertiaDur\n    this.lambda_v0 = lambda / this.v0\n    this.one_ve_v0 = 1 - options.endSpeed / this.v0\n\n    const { modification, modifierArg } = this\n\n    modifierArg.pageCoords = {\n      x: this.startCoords.x + this.targetOffset.x,\n      y: this.startCoords.y + this.targetOffset.y,\n    }\n\n    modification.result = modification.setAll(modifierArg)\n\n    if (modification.result.changed) {\n      this.isModified = true\n      this.modifiedOffset = {\n        x: this.targetOffset.x + modification.result.delta.x,\n        y: this.targetOffset.y + modification.result.delta.y,\n      }\n    }\n\n    this.onNextFrame(() => this.inertiaTick())\n  }\n\n  startSmoothEnd () {\n    this.smoothEnd = true\n    this.isModified = true\n    this.targetOffset = {\n      x: this.modification.result.delta.x,\n      y: this.modification.result.delta.y,\n    }\n\n    this.onNextFrame(() => this.smoothEndTick())\n  }\n\n  onNextFrame (tickFn: () => void) {\n    this.timeout = raf.request(() => {\n      if (this.active) { tickFn() }\n    })\n  }\n\n  inertiaTick () {\n    const { interaction } = this\n    const options = getOptions(interaction)\n    const lambda = options.resistance\n    const t = (interaction._now() - this.t0) / 1000\n\n    if (t < this.te) {\n      const progress =  1 - (Math.exp(-lambda * t) - this.lambda_v0) / this.one_ve_v0\n      let newOffset: Interact.Point\n\n      if (this.isModified) {\n        newOffset = getQuadraticCurvePoint(\n          0, 0,\n          this.targetOffset.x, this.targetOffset.y,\n          this.modifiedOffset.x, this.modifiedOffset.y,\n          progress,\n        )\n      }\n      else {\n        newOffset = {\n          x: this.targetOffset.x * progress,\n          y: this.targetOffset.y * progress,\n        }\n      }\n\n      const delta = { x: newOffset.x - this.currentOffset.x, y: newOffset.y - this.currentOffset.y }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move()\n\n      this.onNextFrame(() => this.inertiaTick())\n    }\n    else {\n      interaction.offsetBy({\n        x: this.modifiedOffset.x - this.currentOffset.x,\n        y: this.modifiedOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  smoothEndTick () {\n    const { interaction } = this\n    const t = interaction._now() - this.t0\n    const { smoothEndDuration: duration } = getOptions(interaction)\n\n    if (t < duration) {\n      const newOffset = {\n        x: easeOutQuad(t, 0, this.targetOffset.x, duration),\n        y: easeOutQuad(t, 0, this.targetOffset.y, duration),\n      }\n      const delta = {\n        x: newOffset.x - this.currentOffset.x,\n        y: newOffset.y - this.currentOffset.y,\n      }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move({ skipModifiers: this.modifierCount })\n\n      this.onNextFrame(() => this.smoothEndTick())\n    }\n    else {\n      interaction.offsetBy({\n        x: this.targetOffset.x - this.currentOffset.x,\n        y: this.targetOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  resume ({ pointer, event, eventTarget }: Interact.SignalArgs['interactions:down']) {\n    const { interaction } = this\n\n    // undo inertia changes to interaction coords\n    interaction.offsetBy({\n      x: -this.currentOffset.x,\n      y: -this.currentOffset.y,\n    })\n\n    // update pointer at pointer down position\n    interaction.updatePointer(pointer, event, eventTarget, true)\n\n    // fire resume signals and event\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'resume',\n    })\n    copyCoords(interaction.coords.prev, interaction.coords.cur)\n\n    this.stop()\n  }\n\n  end () {\n    this.interaction.move()\n    this.interaction.end()\n    this.stop()\n  }\n\n  stop () {\n    this.active = this.smoothEnd = false\n    this.interaction.simulation = null\n    raf.cancel(this.timeout)\n  }\n}\n\nfunction start ({ interaction, event }: Interact.DoPhaseArg<Interact.ActionName, 'end'>) {\n  if (!interaction._interacting || interaction.simulation) {\n    return null\n  }\n\n  const started = interaction.inertia.start(event)\n\n  // prevent action end if inertia or smoothEnd\n  return started ? false : null\n}\n\n// Check if the down event hits the current inertia target\n// control should be return to the user\nfunction resume (arg: Interact.SignalArgs['interactions:down']) {\n  const { interaction, eventTarget } = arg\n  const state = interaction.inertia\n\n  if (!state.active) { return }\n\n  let element = eventTarget as Node\n\n  // climb up the DOM tree from the event target\n  while (is.element(element)) {\n    // if interaction element is the current inertia target element\n    if (element === interaction.element) {\n      state.resume(arg)\n      break\n    }\n\n    element = dom.parentNode(element)\n  }\n}\n\nfunction stop ({ interaction }: { interaction: Interact.Interaction }) {\n  const state = interaction.inertia\n\n  if (state.active) {\n    state.stop()\n  }\n}\n\nfunction getOptions ({ interactable, prepared }: Interact.Interaction) {\n  return interactable &&\n    interactable.options &&\n    prepared.name &&\n    interactable.options[prepared.name].inertia\n}\n\nconst inertia: Interact.Plugin = {\n  id: 'inertia',\n  before: ['modifiers', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.inertia = new InertiaState(interaction)\n    },\n\n    'interactions:before-action-end': start,\n    'interactions:down': resume,\n    'interactions:stop': stop,\n\n    'interactions:before-action-resume': arg => {\n      const { modification } = arg.interaction\n\n      modification.stop(arg)\n      modification.start(arg, arg.interaction.coords.cur.page)\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-inertiastart': arg => arg.interaction.modification.setAndApply(arg),\n    'interactions:action-resume': modifiers.addEventModifiers,\n    'interactions:action-inertiastart': modifiers.addEventModifiers,\n    'interactions:after-action-inertiastart': arg => arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-resume': arg => arg.interaction.modification.restoreInteractionCoords(arg),\n  },\n}\n\n// http://stackoverflow.com/a/5634528/2280888\nfunction _getQBezierValue (t: number, p1: number, p2: number, p3: number) {\n  const iT = 1 - t\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3\n}\n\nfunction getQuadraticCurvePoint (\n  startX: number, startY: number, cpX: number, cpY: number, endX: number, endY: number, position: number) {\n  return {\n    x:  _getQBezierValue(position, startX, cpX, endX),\n    y:  _getQBezierValue(position, startY, cpY, endY),\n  }\n}\n\n// http://gizma.com/easing/\nfunction easeOutQuad (t: number, b: number, c: number, d: number) {\n  t /= d\n  return -c * t * (t - 2) + b\n}\n\nexport default inertia\n","import * as Interact from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport normalize, { NormalizedListeners } from '@interactjs/utils/normalizeListeners'\n\nfunction fireUntilImmediateStopped<\n  T extends Interact.ActionName,\n  P extends Interact.EventPhase,\n> (event: Interact.InteractEvent<T, P>, listeners: Interact.Listener[]) {\n  for (const listener of listeners) {\n    if (event.immediatePropagationStopped) { break }\n\n    listener(event)\n  }\n}\n\nexport class Eventable {\n  options: any\n  types: NormalizedListeners = {}\n  propagationStopped = false\n  immediatePropagationStopped = false\n  global: any\n\n  constructor (options?: { [index: string]: any }) {\n    this.options = extend({}, options || {})\n  }\n\n  fire (event: any) {\n    let listeners: Interact.Listener[]\n    const global = this.global\n\n    // Interactable#on() listeners\n    // tslint:disable no-conditional-assignment\n    if ((listeners = this.types[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type]))  {\n      fireUntilImmediateStopped(event, listeners)\n    }\n  }\n\n  on (type: string, listener: Interact.ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      this.types[type] = arr.merge(this.types[type] || [], listeners[type])\n    }\n  }\n\n  off (type: string, listener: Interact.ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      const eventList = this.types[type]\n\n      if (!eventList || !eventList.length) { continue }\n\n      for (const subListener of listeners[type]) {\n        const index = eventList.indexOf(subListener)\n\n        if (index !== -1) {\n          eventList.splice(index, 1)\n        }\n      }\n    }\n  }\n\n  getRect (_element: Interact.Element): Interact.Rect {\n    return null\n  }\n}\n","import * as Interact from '@interactjs/types/index'\n\nexport default function isNonNativeEvent (type: string, actions: Interact.Actions) {\n  if (actions.phaselessTypes[type]) { return true }\n\n  for (const name in actions.map) {\n    if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) {\n      return true\n    }\n  }\n\n  return false\n}\n","/* eslint-disable no-dupe-class-members */\nimport { ActionMap } from '@interactjs/core/scope'\nimport * as Interact from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport { ActionDefaults, Defaults, Options } from './defaultOptions'\nimport isNonNativeEvent from './isNonNativeEvent'\n\ntype IgnoreValue = string | Interact.Element | boolean\ntype DeltaSource = 'page' | 'client'\n\n/** */\nexport class Interactable implements Partial<Eventable> {\n  /** @internal */ get _defaults (): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {} as ActionDefaults,\n    }\n  }\n\n  readonly options!: Required<Options>\n  readonly _actions: Interact.Actions\n  readonly target: Interact.Target\n  readonly events = new Eventable()\n  readonly _context: Interact.Context\n  readonly _win: Window\n  readonly _doc: Document\n  readonly _scopeEvents: Interact.Scope['events']\n\n  /** @internal */ _rectChecker?: typeof Interactable.prototype.getRect\n\n  /** */\n  constructor (target: Interact.Target, options: any, defaultContext: Document | Interact.Element, scopeEvents: Interact.Scope['events']) {\n    this._actions = options.actions\n    this.target   = target\n    this._context = options.context || defaultContext\n    this._win     = getWindow(trySelector(target) ? this._context : target)\n    this._doc     = this._win.document\n    this._scopeEvents = scopeEvents\n\n    this.set(options)\n  }\n\n  setOnEvents (actionName: Interact.ActionName, phases: NonNullable<any>) {\n    if (is.func(phases.onstart)) { this.on(`${actionName}start`, phases.onstart) }\n    if (is.func(phases.onmove)) { this.on(`${actionName}move`, phases.onmove) }\n    if (is.func(phases.onend)) { this.on(`${actionName}end`, phases.onend) }\n    if (is.func(phases.oninertiastart)) { this.on(`${actionName}inertiastart`, phases.oninertiastart) }\n\n    return this\n  }\n\n  updatePerActionListeners (actionName: Interact.ActionName, prev: Interact.Listeners, cur: Interact.Listeners) {\n    if (is.array(prev) || is.object(prev)) {\n      this.off(actionName, prev)\n    }\n\n    if (is.array(cur) || is.object(cur)) {\n      this.on(actionName, cur)\n    }\n  }\n\n  setPerAction (actionName: Interact.ActionName, options: Interact.OrBoolean<Options>) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName_ in options) {\n      const optionName = optionName_ as keyof Interact.PerActionDefaults\n      const actionOptions = this.options[actionName]\n      const optionValue: any = options[optionName]\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Interact.Listeners)\n      }\n\n      // if the option value is an array\n      if (is.array<any>(optionValue)) {\n        (actionOptions[optionName] as any) = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (is.plainObject(optionValue)) {\n        // copy the object\n        (actionOptions[optionName] as any) = extend(\n          actionOptions[optionName] || {} as any,\n          clone(optionValue))\n\n        // set anabled field to true if it exists in the defaults\n        if (is.object(defaults.perAction[optionName]) && 'enabled' in (defaults.perAction[optionName] as any)) {\n          (actionOptions[optionName] as any).enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {\n        (actionOptions[optionName] as any).enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        (actionOptions[optionName] as any) = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {Interact.Rect} The object's bounding rectangle.\n   */\n  getRect (element: Interact.Element) {\n    element = element || (is.element(this.target)\n      ? this.target\n      : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker (): (element: Interact.Element) => any | null\n  rectChecker (checker: (element: Interact.Element) => any): this\n  rectChecker (checker?: (element: Interact.Element) => any) {\n    if (is.func(checker)) {\n      this._rectChecker = checker\n\n      this.getRect = element => {\n        const rect = extend({}, this._rectChecker(element))\n\n        if (!('width' in rect)) {\n          rect.width = rect.right - rect.left\n          rect.height = rect.bottom - rect.top\n        }\n\n        return rect\n      }\n\n      return this\n    }\n\n    if (checker === null) {\n      delete this.getRect\n      delete this._rectChecker\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  _backCompatOption (optionName: keyof Interact.Options, newValue: any) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      (this.options[optionName] as any) = newValue\n\n      for (const action in this._actions.map) {\n        (this.options[action as keyof ActionMap] as any)[optionName] = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue: any) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource (): DeltaSource\n  deltaSource (newValue: DeltaSource): this\n  deltaSource (newValue?: DeltaSource) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context\n  }\n\n  inContext (element: Document | Node) {\n    return (this._context === element.ownerDocument ||\n            nodeContains(this._context, element))\n  }\n\n  testIgnoreAllow (\n    this: Interactable,\n    options: { ignoreFrom?: IgnoreValue, allowFrom?: IgnoreValue },\n    targetNode: Node,\n    eventTarget: Node,\n  ) {\n    return (!this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &&\n            this.testAllow(options.allowFrom, targetNode, eventTarget))\n  }\n\n  testAllow (\n    this: Interactable,\n    allowFrom: IgnoreValue,\n    targetNode: Node,\n    element: Node,\n  ) {\n    if (!allowFrom) { return true }\n\n    if (!is.element(element)) { return false }\n\n    if (is.string(allowFrom)) {\n      return matchesUpTo(element, allowFrom, targetNode)\n    }\n    else if (is.element(allowFrom)) {\n      return nodeContains(allowFrom, element)\n    }\n\n    return false\n  }\n\n  testIgnore (\n    this: Interactable,\n    ignoreFrom: IgnoreValue,\n    targetNode: Node,\n    element: Node,\n  ) {\n    if (!ignoreFrom || !is.element(element)) { return false }\n\n    if (is.string(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, targetNode)\n    }\n    else if (is.element(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element)\n    }\n\n    return false\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire (iEvent: { type: string, [index: string]: any }) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  _onOff (method: 'on' | 'off', typeArg: Interact.EventTypes, listenerArg?: Interact.ListenersArg | null, options?: any) {\n    if (is.object(typeArg) && !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const addRemove = method === 'on' ? 'add' : 'remove'\n    const listeners = normalizeListeners(typeArg, listenerArg)\n\n    for (let type in listeners) {\n      if (type === 'wheel') { type = browser.wheelEvent }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (isNonNativeEvent(type, this._actions)) {\n          this.events[method](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          this._scopeEvents[`${addRemove}Delegate` as 'addDelegate' | 'removeDelegate'](this.target, this._context, type, listener, options)\n        }\n        // remove listener from this Interactable's element\n        else {\n          this._scopeEvents[addRemove](this.target, type, listener, options)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on (types: Interact.EventTypes, listener?: Interact.ListenersArg, options?: any) {\n    return this._onOff('on', types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off (types: string | string[] | Interact.EventTypes, listener?: Interact.ListenersArg, options?: any) {\n    return this._onOff('off', types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options: Interact.OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    (this.options as Required<Options>) = clone(defaults.base) as Required<Options>\n\n    for (const actionName_ in this._actions.methodDict) {\n      const actionName = actionName_ as Interact.ActionName\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n\n      ;(this as unknown as Interactable & { [key: string]: Interact.ActionMethod<unknown> })[methodName](options[actionName])\n    }\n\n    for (const setting in options) {\n      if (is.func((this as any)[setting])) {\n        (this as any)[setting](options[setting as keyof typeof options])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   */\n  unset () {\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in this._scopeEvents.delegatedEvents) {\n        const delegated = this._scopeEvents.delegatedEvents[type]\n\n        for (let i = delegated.length - 1; i >= 0; i--) {\n          const { selector, context, listeners } = delegated[i]\n\n          if (selector === this.target && context === this._context) {\n            delegated.splice(i, 1)\n          }\n\n          for (let l = listeners.length - 1; l >= 0; l--) {\n            this._scopeEvents.removeDelegate(this.target, this._context, type, listeners[l][0], listeners[l][1])\n          }\n        }\n      }\n    }\n    else {\n      this._scopeEvents.remove(this.target as Node, 'all')\n    }\n  }\n}\n","import { Interactable } from '@interactjs/core/Interactable'\nimport * as Interact from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactable:new': {\n      interactable: Interact.Interactable\n      target: Interact.Target\n      options: Interact.OptionsArg\n      win: Window\n    }\n  }\n}\n\ninterface InteractableScopeProp {\n  context: Document | Interact.Element\n  interactable: Interact.Interactable\n}\n\nexport class InteractableSet {\n  // all set interactables\n  list: Interact.Interactable[] = []\n\n  selectorMap: {\n    [selector: string]: InteractableScopeProp[]\n  } = {}\n\n  scope: Interact.Scope\n\n  constructor (scope: Interact.Scope) {\n    this.scope = scope\n    scope.addListeners({\n      'interactable:unset': ({ interactable }) => {\n        const { target, _context: context } = interactable\n        const targetMappings: InteractableScopeProp[] = is.string(target)\n          ? this.selectorMap[target]\n          : (target as any)[this.scope.id]\n\n        const targetIndex = arr.findIndex(targetMappings, m => m.context === context)\n        if (targetMappings[targetIndex]) {\n        // Destroying mappingInfo's context and interactable\n          targetMappings[targetIndex].context = null\n          targetMappings[targetIndex].interactable = null\n        }\n        targetMappings.splice(targetIndex, 1)\n      },\n    })\n  }\n\n  new (target: Interact.Target, options?: any): Interactable {\n    options = extend(options || {}, {\n      actions: this.scope.actions,\n    })\n    const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events)\n    const mappingInfo = { context: interactable._context, interactable }\n\n    this.scope.addDocument(interactable._doc)\n    this.list.push(interactable)\n\n    if (is.string(target)) {\n      if (!this.selectorMap[target]) { this.selectorMap[target] = [] }\n      this.selectorMap[target].push(mappingInfo)\n    } else {\n      if (!((interactable.target as any)[this.scope.id])) {\n        Object.defineProperty(target, this.scope.id, {\n          value: [],\n          configurable: true,\n        })\n      }\n\n      (target as any)[this.scope.id].push(mappingInfo)\n    }\n\n    this.scope.fire('interactable:new', {\n      target,\n      options,\n      interactable,\n      win: this.scope._win,\n    })\n\n    return interactable\n  }\n\n  get (target: Interact.Target, options?: Interact.Options) {\n    const context = (options && options.context) || this.scope.document\n    const isSelector = is.string(target)\n    const targetMappings: InteractableScopeProp[] = isSelector\n      ? this.selectorMap[target as string]\n      : (target as any)[this.scope.id]\n\n    if (!targetMappings) { return null }\n\n    const found = arr.find(\n      targetMappings,\n      m => m.context === context &&\n        (isSelector || m.interactable.inContext(target as any)))\n\n    return found && found.interactable\n  }\n\n  forEachMatch<T> (node: Node, callback: (interactable: Interact.Interactable) => T) {\n    for (const interactable of this.list) {\n      let ret: void | T\n\n      if ((is.string(interactable.target)\n      // target is a selector and the element matches\n        ? (is.element(node) && domUtils.matchesSelector(node, interactable.target))\n        // target is the element\n        : node === interactable.target) &&\n        // the element is in context\n        (interactable.inContext(node))) {\n        ret = callback(interactable)\n      }\n\n      if (ret !== undefined) {\n        return ret\n      }\n    }\n  }\n}\n","import * as Interact from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport pExtend from '@interactjs/utils/pointerExtend'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    events: ReturnType<typeof install>\n  }\n}\n\ntype Listener = (event: Event | FakeEvent) => any\n\nfunction install (scope: Interact.Scope) {\n  const targets: Array<{\n    eventTarget: EventTarget\n    events: { [type: string]: Listener[] }\n  }> = []\n\n  const delegatedEvents: {\n    [type: string]: Array<{\n      selector: string\n      context: Node\n      listeners: Array<[Listener, { capture: boolean, passive: boolean }]>\n    }>\n  } = {}\n  const documents: Document[] = []\n\n  const eventsMethods = {\n    add,\n    remove,\n\n    addDelegate,\n    removeDelegate,\n\n    delegateListener,\n    delegateUseCapture,\n    delegatedEvents,\n    documents,\n\n    targets,\n\n    supportsOptions: false,\n    supportsPassive: false,\n  }\n\n  // check if browser supports passive events and options arg\n  scope.document.createElement('div').addEventListener('test', null, {\n    get capture () { return (eventsMethods.supportsOptions = true) },\n    get passive () { return (eventsMethods.supportsPassive = true) },\n  })\n\n  scope.events = eventsMethods\n\n  function add (eventTarget: EventTarget, type: string, listener: Listener, optionalArg?: boolean | any) {\n    const options = getOptions(optionalArg)\n    let target = arr.find(targets, t => t.eventTarget === eventTarget)\n\n    if (!target) {\n      target = {\n        eventTarget,\n        events: {},\n      }\n\n      targets.push(target)\n    }\n\n    if (!target.events[type]) {\n      target.events[type] = []\n    }\n\n    if (eventTarget.addEventListener && !arr.contains(target.events[type], listener)) {\n      eventTarget.addEventListener(type, listener as any, eventsMethods.supportsOptions ? options : options.capture)\n      target.events[type].push(listener)\n    }\n  }\n\n  function remove (eventTarget: EventTarget, type: string, listener?: 'all' | Listener, optionalArg?: boolean | any) {\n    const options = getOptions(optionalArg)\n    const targetIndex = arr.findIndex(targets, t => t.eventTarget === eventTarget)\n    const target = targets[targetIndex]\n\n    if (!target || !target.events) {\n      return\n    }\n\n    if (type === 'all') {\n      for (type in target.events) {\n        if (target.events.hasOwnProperty(type)) {\n          remove(eventTarget, type, 'all')\n        }\n      }\n      return\n    }\n\n    let typeIsEmpty = false\n    const typeListeners = target.events[type]\n\n    if (typeListeners) {\n      if (listener === 'all') {\n        for (let i = typeListeners.length - 1; i >= 0; i--) {\n          remove(eventTarget, type, typeListeners[i], options)\n        }\n        return\n      }\n      else {\n        for (let i = 0; i < typeListeners.length; i++) {\n          if (typeListeners[i] === listener) {\n            eventTarget.removeEventListener(type, listener as any, eventsMethods.supportsOptions ? options : options.capture)\n            typeListeners.splice(i, 1)\n\n            if (typeListeners.length === 0) {\n              delete target.events[type]\n              typeIsEmpty = true\n            }\n\n            break\n          }\n        }\n      }\n    }\n\n    if (typeIsEmpty && !Object.keys(target.events).length) {\n      targets.splice(targetIndex, 1)\n    }\n  }\n\n  function addDelegate (selector: string, context: Node, type: string, listener: Listener, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    if (!delegatedEvents[type]) {\n      delegatedEvents[type] = []\n\n      // add delegate listener functions\n      for (const doc of documents) {\n        add(doc, type, delegateListener)\n        add(doc, type, delegateUseCapture, true)\n      }\n    }\n\n    const delegates = delegatedEvents[type]\n    let delegate = arr.find(delegates, d => d.selector === selector && d.context === context)\n\n    if (!delegate) {\n      delegate = { selector, context, listeners: [] }\n      delegates.push(delegate)\n    }\n\n    delegate.listeners.push([listener, options])\n  }\n\n  function removeDelegate (\n    selector: string,\n    context: Document | Interact.Element,\n    type: string,\n    listener?: Listener,\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    const delegates = delegatedEvents[type]\n    let matchFound = false\n    let index: number\n\n    if (!delegates) { return }\n\n    // count from last index of delegated to 0\n    for (index = delegates.length - 1; index >= 0; index--) {\n      const cur = delegates[index]\n      // look for matching selector and context Node\n      if (cur.selector === selector && cur.context === context) {\n        const { listeners } = cur\n\n        // each item of the listeners array is an array: [function, capture, passive]\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          const [fn, { capture, passive }] = listeners[i]\n\n          // check if the listener functions and capture and passive flags match\n          if (fn === listener && capture === options.capture && passive === options.passive) {\n            // remove the listener from the array of listeners\n            listeners.splice(i, 1)\n\n            // if all listeners for this target have been removed\n            // remove the target from the delegates array\n            if (!listeners.length) {\n              delegates.splice(index, 1)\n\n              // remove delegate function from context\n              remove(context, type, delegateListener)\n              remove(context, type, delegateUseCapture, true)\n            }\n\n            // only remove one listener\n            matchFound = true\n            break\n          }\n        }\n\n        if (matchFound) { break }\n      }\n    }\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener (event: Event | FakeEvent, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    const fakeEvent = new FakeEvent(event as Event)\n    const delegates = delegatedEvents[event.type]\n    const [eventTarget] = (pointerUtils.getEventTargets(event as Event))\n    let element: Node = eventTarget\n\n    // climb up document tree looking for selector matches\n    while (is.element(element)) {\n      for (let i = 0; i < delegates.length; i++) {\n        const cur = delegates[i]\n        const { selector, context } = cur\n\n        if (domUtils.matchesSelector(element, selector) &&\n            domUtils.nodeContains(context, eventTarget) &&\n            domUtils.nodeContains(context, element)) {\n          const { listeners } = cur\n\n          fakeEvent.currentTarget = element\n\n          for (const [fn, { capture, passive }] of listeners) {\n            if (capture === options.capture && passive === options.passive) {\n              fn(fakeEvent)\n            }\n          }\n        }\n      }\n\n      element = domUtils.parentNode(element)\n    }\n  }\n\n  function delegateUseCapture (this: Interact.Element, event: Event | FakeEvent) {\n    return delegateListener.call(this, event, true)\n  }\n\n  // for type inferrence\n  return eventsMethods\n}\n\nclass FakeEvent implements Partial<Event> {\n  currentTarget: Node\n  originalEvent: Event\n  type: string\n\n  constructor (originalEvent: Event) {\n    this.originalEvent = originalEvent\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault () {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation () {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation () {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nfunction getOptions (param: { [index: string]: any } | boolean): { capture: boolean, passive: boolean } {\n  if (!is.object(param)) { return { capture: !!param, passive: false } }\n\n  const options = extend({}, param) as any\n\n  options.capture = !!param.capture\n  options.passive = !!param.passive\n\n  return options\n}\n\nexport default {\n  id: 'events',\n  install,\n}\n","/** @module interact */\nimport * as Interact from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport { Interactable } from './Interactable'\nimport { Options } from './defaultOptions'\nimport isNonNativeEvent from './isNonNativeEvent'\n\nexport interface InteractStatic {\n  (target: Interact.Target, options?: Options): Interactable\n  getPointerAverage: typeof pointerUtils.pointerAverage\n  getTouchBBox: typeof pointerUtils.touchBBox\n  getTouchDistance: typeof pointerUtils.touchDistance\n  getTouchAngle: typeof pointerUtils.touchAngle\n  getElementRect: typeof domUtils.getElementRect\n  getElementClientRect: typeof domUtils.getElementClientRect\n  matchesSelector: typeof domUtils.matchesSelector\n  closest: typeof domUtils.closest\n  /** @internal */ globalEvents: any\n  version: string\n  /** @internal */ scope: Interact.Scope\n  use(plugin: Interact.Plugin, options?: {\n    [key: string]: any\n  }): any\n  isSet(target: Interact.Element, options?: any): boolean\n  on(type: string | Interact.EventTypes, listener: Interact.ListenersArg, options?: object): any\n  off(type: Interact.EventTypes, listener: any, options?: object): any\n  debug(): any\n  supportsTouch(): boolean\n  supportsPointerEvent(): boolean\n  stop(): any\n  pointerMoveTolerance(newValue?: number): any\n  addDocument(doc: Document, options?: object): void\n  removeDocument(doc: Document): void\n}\n\nexport function createInteractStatic (scope: Interact.Scope): Interact.InteractStatic {\n  /**\n   * ```js\n   * interact('#draggable').draggable(true)\n   *\n   * var rectables = interact('rect')\n   * rectables\n   *   .gesturable(true)\n   *   .on('gesturemove', function (event) {\n   *       // ...\n   *   })\n   * ```\n   *\n   * The methods of this variable can be used to set elements as interactables\n   * and also to change various default settings.\n   *\n   * Calling it as a function and passing an element or a valid CSS selector\n   * string returns an Interactable object which has various methods to configure\n   * it.\n   *\n   * @global\n   *\n   * @param {Element | string} target The HTML or SVG Element to interact with\n   * or CSS selector\n   * @return {Interactable}\n   */\n  const interact = ((target, options) => {\n    let interactable = scope.interactables.get(target, options)\n\n    if (!interactable) {\n      interactable = scope.interactables.new(target, options)\n      interactable.events.global = interact.globalEvents\n    }\n\n    return interactable\n  }) as InteractStatic\n\n  // expose the functions used to calculate multi-touch properties\n  interact.getPointerAverage = pointerUtils.pointerAverage\n  interact.getTouchBBox = pointerUtils.touchBBox\n  interact.getTouchDistance = pointerUtils.touchDistance\n  interact.getTouchAngle = pointerUtils.touchAngle\n\n  interact.getElementRect = domUtils.getElementRect\n  interact.getElementClientRect = domUtils.getElementClientRect\n  interact.matchesSelector = domUtils.matchesSelector\n  interact.closest = domUtils.closest\n\n  interact.globalEvents = {} as any\n\n  // eslint-disable-next-line no-undef\n  interact.version = process.env.npm_package_version\n  interact.scope = scope\n  /**\n  * Use a plugin\n  *\n  * @alias module:interact.use\n  *\n  * @param {Object} plugin\n  * @param {function} plugin.install\n  * @return {Interact.InteractStatic}\n   */\n  interact.use = function (plugin, options) {\n    this.scope.usePlugin(plugin, options)\n\n    return this\n  }\n\n  /**\n   * Check if an element or selector has been set with the {@link interact}\n   * function\n   *\n   * @alias module:interact.isSet\n   *\n   * @param {Element} element The Element being searched for\n   * @return {boolean} Indicates if the element or CSS selector was previously\n   * passed to interact\n   */\n  interact.isSet = function (target, options) {\n    return !!this.scope.interactables.get(target, options && options.context)\n  }\n\n  /**\n   * Add a global listener for an InteractEvent or adds a DOM event to `document`\n   *\n   * @alias module:interact.on\n   *\n   * @param {string | array | object} type The types of events to listen for\n   * @param {function} listener The function event (s)\n   * @param {object | boolean} [options] object or useCapture flag for\n   * addEventListener\n   * @return {object} interact\n   */\n  interact.on = function (type: string | Interact.EventTypes, listener: Interact.ListenersArg, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of (type as any[])) {\n        this.on(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.on(prop, (type as any)[prop], listener)\n      }\n\n      return this\n    }\n\n    // if it is an InteractEvent type, add listener to globalEvents\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      // if this type of event was never bound\n      if (!this.globalEvents[type]) {\n        this.globalEvents[type] = [listener]\n      }\n      else {\n        this.globalEvents[type].push(listener)\n      }\n    }\n    // If non InteractEvent type, addEventListener to document\n    else {\n      this.scope.events.add(this.scope.document, type, listener as Interact.Listener, { options })\n    }\n\n    return this\n  }\n\n  /**\n   * Removes a global InteractEvent listener or DOM event from `document`\n   *\n   * @alias module:interact.off\n   *\n   * @param {string | array | object} type The types of events that were listened\n   * for\n   * @param {function} listener The listener function to be removed\n   * @param {object | boolean} options [options] object or useCapture flag for\n   * removeEventListener\n   * @return {object} interact\n   */\n  interact.off = function (type: Interact.EventTypes, listener: any, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type) {\n        this.off(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.off(prop, type[prop], listener)\n      }\n\n      return this\n    }\n\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      let index: number\n\n      if (type in this.globalEvents &&\n            (index = this.globalEvents[type].indexOf(listener)) !== -1) {\n        this.globalEvents[type].splice(index, 1)\n      }\n    }\n    else {\n      this.scope.events.remove(this.scope.document, type, listener, options)\n    }\n\n    return this\n  }\n\n  interact.debug = function () {\n    return this.scope\n  }\n\n  /**\n   * @alias module:interact.supportsTouch\n   *\n   * @return {boolean} Whether or not the browser supports touch input\n   */\n  interact.supportsTouch = function () {\n    return browser.supportsTouch\n  }\n\n  /**\n   * @alias module:interact.supportsPointerEvent\n   *\n   * @return {boolean} Whether or not the browser supports PointerEvents\n   */\n  interact.supportsPointerEvent = function () {\n    return browser.supportsPointerEvent\n  }\n\n  /**\n   * Cancels all interactions (end events are not fired)\n   *\n   * @alias module:interact.stop\n   *\n   * @return {object} interact\n   */\n  interact.stop = function () {\n    for (const interaction of this.scope.interactions.list) {\n      interaction.stop()\n    }\n\n    return this\n  }\n\n  /**\n   * Returns or sets the distance the pointer must be moved before an action\n   * sequence occurs. This also affects tolerance for tap events.\n   *\n   * @alias module:interact.pointerMoveTolerance\n   *\n   * @param {number} [newValue] The movement from the start position must be greater than this value\n   * @return {interact | number}\n   */\n  interact.pointerMoveTolerance = function (newValue?: number) {\n    if (is.number(newValue)) {\n      this.scope.interactions.pointerMoveTolerance = newValue\n\n      return this\n    }\n\n    return this.scope.interactions.pointerMoveTolerance\n  }\n\n  interact.addDocument = function (doc: Document, options?: object) {\n    this.scope.addDocument(doc, options)\n  }\n\n  interact.removeDocument = function (doc: Document) {\n    this.scope.removeDocument(doc)\n  }\n\n  return interact as any\n}\n","import * as Interact from '@interactjs/types/index'\nimport * as dom from '@interactjs/utils/domUtils'\n\nexport interface SearchDetails {\n  pointer: Interact.PointerType\n  pointerId: number\n  pointerType: string\n  eventType: string\n  eventTarget: Interact.EventTarget\n  curEventTarget: Interact.EventTarget\n  scope: Interact.Scope\n}\n\nconst finder = {\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\n\n  search (details: SearchDetails) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume ({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget as Node\n\n      if (interaction.simulation && interaction.simulation.allowResume &&\n          (interaction.pointerType === pointerType)) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen ({ pointerId, pointerType, eventType, scope }: SearchDetails) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !hasPointerId(interaction, pointerId)) { continue }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer ({ pointerId, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle ({ pointerType, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.interactable\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !(target.options.gesture && target.options.gesture.enabled)) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length >= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() && (pointerType === interaction.pointerType)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId (interaction: Interact.Interaction, pointerId: number) {\n  return interaction.pointers.some(({ id }) => id === pointerId)\n}\n\nexport default finder\n","import * as Interact from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { nodeContains } from '@interactjs/utils/domUtils'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport InteractionBase from './Interaction'\nimport interactablePreventDefault from './interactablePreventDefault'\nimport finder, { SearchDetails } from './interactionFinder'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    Interaction: typeof InteractionBase\n    interactions: {\n      new: <T extends ActionName> (options: any) => InteractionBase<T>\n      list: InteractionBase[]\n      listeners: { [type: string]: Interact.Listener }\n      docEvents: Array<{ type: string, listener: Interact.Listener }>\n      pointerMoveTolerance: number\n    }\n    prevTouchTime: number\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:find': {\n      interaction: InteractionBase\n      searchDetails: SearchDetails\n    }\n  }\n}\n\nconst methodNames = [\n  'pointerDown', 'pointerMove', 'pointerUp',\n  'updatePointer', 'removePointer', 'windowBlur',\n]\n\nfunction install (scope: Interact.Scope) {\n  const listeners = {} as any\n\n  for (const method of methodNames) {\n    listeners[method] = doOnInteractions(method, scope)\n  }\n\n  const pEventTypes = browser.pEventTypes\n  let docEvents: typeof scope.interactions.docEvents\n\n  if (domObjects.PointerEvent) {\n    docEvents = [\n      { type: pEventTypes.down,   listener: releasePointersOnRemovedEls },\n      { type: pEventTypes.down,   listener: listeners.pointerDown },\n      { type: pEventTypes.move,   listener: listeners.pointerMove },\n      { type: pEventTypes.up,     listener: listeners.pointerUp },\n      { type: pEventTypes.cancel, listener: listeners.pointerUp },\n    ]\n  }\n  else {\n    docEvents = [\n      { type: 'mousedown', listener: listeners.pointerDown },\n      { type: 'mousemove', listener: listeners.pointerMove },\n      { type: 'mouseup', listener: listeners.pointerUp },\n\n      { type: 'touchstart', listener: releasePointersOnRemovedEls },\n      { type: 'touchstart', listener: listeners.pointerDown },\n      { type: 'touchmove', listener: listeners.pointerMove },\n      { type: 'touchend', listener: listeners.pointerUp },\n      { type: 'touchcancel', listener: listeners.pointerUp },\n    ]\n  }\n\n  docEvents.push({\n    type: 'blur',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        interaction.documentBlur(event)\n      }\n    },\n  })\n\n  // for ignoring browser's simulated mouse events\n  scope.prevTouchTime = 0\n\n  scope.Interaction = class <T extends Interact.ActionName> extends InteractionBase<T> {\n    get pointerMoveTolerance () {\n      return scope.interactions.pointerMoveTolerance\n    }\n\n    set pointerMoveTolerance (value) {\n      scope.interactions.pointerMoveTolerance = value\n    }\n\n    _now () { return scope.now() }\n  }\n\n  scope.interactions = {\n    // all active and idle interactions\n    list: [],\n    new<T extends Interact.ActionName> (options: { pointerType?: string, scopeFire?: Interact.Scope['fire'] }) {\n      options.scopeFire = (name, arg) => scope.fire(name, arg)\n\n      const interaction = new scope.Interaction<T>(options as Required<typeof options>)\n\n      scope.interactions.list.push(interaction)\n      return interaction\n    },\n    listeners,\n    docEvents,\n    pointerMoveTolerance: 1,\n  }\n\n  function releasePointersOnRemovedEls () {\n    // for all inactive touch interactions with pointers down\n    for (const interaction of scope.interactions.list) {\n      if (!interaction.pointerIsDown ||\n        interaction.pointerType !== 'touch' ||\n        interaction._interacting) {\n        continue\n      }\n\n      // if a pointer is down on an element that is no longer in the DOM tree\n      for (const pointer of interaction.pointers) {\n        if (!scope.documents.some(({ doc }) => nodeContains(doc, pointer.downTarget))) {\n          // remove the pointer from the interaction\n          interaction.removePointer(pointer.pointer, pointer.event)\n        }\n      }\n    }\n  }\n\n  scope.usePlugin(interactablePreventDefault)\n}\n\nfunction doOnInteractions (method: string, scope: Interact.Scope) {\n  return function (event: Event) {\n    const interactions = scope.interactions.list\n\n    const pointerType = pointerUtils.getPointerType(event)\n    const [eventTarget, curEventTarget] = pointerUtils.getEventTargets(event)\n    const matches = [] // [ [pointer, interaction], ...]\n\n    if (/^touch/.test(event.type)) {\n      scope.prevTouchTime = scope.now()\n\n      // @ts-expect-error\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch\n        const pointerId = pointerUtils.getPointerId(pointer)\n        const searchDetails: SearchDetails = {\n          pointer,\n          pointerId,\n          pointerType,\n          eventType: event.type,\n          eventTarget,\n          curEventTarget,\n          scope,\n        }\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n    else {\n      let invalidPointer = false\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < interactions.length && !invalidPointer; i++) {\n          invalidPointer = interactions[i].pointerType !== 'mouse' && interactions[i].pointerIsDown\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer = invalidPointer ||\n          (scope.now() - scope.prevTouchTime < 500) ||\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          event.timeStamp === 0\n      }\n\n      if (!invalidPointer) {\n        const searchDetails = {\n          pointer: event as PointerEvent,\n          pointerId: pointerUtils.getPointerId(event as PointerEvent),\n          pointerType,\n          eventType: event.type,\n          curEventTarget,\n          eventTarget,\n          scope,\n        }\n\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n\n    // eslint-disable-next-line no-shadow\n    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {\n      interaction[method](pointer, event, eventTarget, curEventTarget)\n    }\n  }\n}\n\nfunction getInteraction (searchDetails: SearchDetails) {\n  const { pointerType, scope } = searchDetails\n\n  const foundInteraction = finder.search(searchDetails)\n  const signalArg = { interaction: foundInteraction, searchDetails }\n\n  scope.fire('interactions:find', signalArg)\n\n  return signalArg.interaction || scope.interactions.new({ pointerType })\n}\n\nfunction onDocSignal<T extends 'scope:add-document' | 'scope:remove-document'> ({ doc, scope, options }: Interact.SignalArgs[T], eventMethodName: 'add' | 'remove') {\n  const { interactions: { docEvents }, events } = scope\n  const eventMethod = events[eventMethodName]\n\n  if (scope.browser.isIOS && !options.events) {\n    options.events = { passive: false }\n  }\n\n  // delegate event listener\n  for (const eventType in events.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener)\n    eventMethod(doc, eventType, events.delegateUseCapture, true)\n  }\n\n  const eventOptions = options && options.events\n\n  for (const { type, listener } of docEvents) {\n    eventMethod(doc, type, listener, eventOptions)\n  }\n}\n\nconst interactions: Interact.Plugin = {\n  id: 'core/interactions',\n  install,\n  listeners: {\n    'scope:add-document': arg => onDocSignal(arg, 'add'),\n    'scope:remove-document': arg => onDocSignal(arg, 'remove'),\n    'interactable:unset': ({ interactable }, scope) => {\n      // Stop and destroy related interactions when an Interactable is unset\n      for (let i = scope.interactions.list.length - 1; i >= 0; i--) {\n        const interaction = scope.interactions.list[i]\n\n        if (interaction.interactable !== interactable) { continue }\n\n        interaction.stop()\n        scope.fire('interactions:destroy', { interaction })\n        interaction.destroy()\n\n        if (scope.interactions.list.length > 2) {\n          scope.interactions.list.splice(i, 1)\n        }\n      }\n    },\n  },\n  onDocSignal,\n  doOnInteractions,\n  methodNames,\n}\n\nexport default interactions\n","import * as Interact from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport domObjects from '@interactjs/utils/domObjects'\nimport extend from '@interactjs/utils/extend'\nimport raf from '@interactjs/utils/raf'\nimport * as win from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport { InteractEvent, PhaseMap } from './InteractEvent'\nimport { Interactable as InteractableBase } from './Interactable'\nimport { InteractableSet } from './InteractableSet'\nimport { defaults } from './defaultOptions'\nimport events from './events'\nimport { createInteractStatic } from './interactStatic'\nimport interactions from './interactions'\n\nexport interface SignalArgs {\n  'scope:add-document': DocSignalArg\n  'scope:remove-document': DocSignalArg\n  'interactable:unset': { interactable: InteractableBase }\n  'interactable:set': { interactable: InteractableBase, options: Interact.OptionsArg }\n  'interactions:destroy': { interaction: Interact.Interaction }\n}\n\nexport type ListenerName = keyof SignalArgs\n\nexport type ListenerMap = {\n  [P in ListenerName]?: (arg: SignalArgs[P], scope: Scope, signalName: P) => void | boolean\n}\n\ninterface DocSignalArg {\n  doc: Document\n  window: Window\n  scope: Scope\n  options?: { [index: string]: any }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionMap { // tslint:disable-line no-empty-interface\n}\n\nexport type ActionName = keyof ActionMap\n\nexport interface Actions {\n  map: ActionMap\n  phases: PhaseMap\n  methodDict: { [P in ActionName]?: string }\n  phaselessTypes: { [type: string]: true }\n}\n\nexport interface Plugin {\n  [key: string]: any\n  id?: string\n  listeners?: ListenerMap\n  before?: string[]\n  install? (scope: Scope, options?: any): void\n}\n\nexport class Scope {\n  id = `__interact_scope_${Math.floor(Math.random() * 100)}`\n  isInitialized = false\n  listenerMaps: Array<{\n    map: ListenerMap\n    id: string\n  }> = []\n\n  browser = browser\n  defaults = clone(defaults) as typeof defaults\n  Eventable = Eventable\n  actions: Actions = {\n    map: {},\n    phases: {\n      start: true,\n      move: true,\n      end: true,\n    },\n    methodDict: {},\n    phaselessTypes: {},\n  }\n\n  interactStatic = createInteractStatic(this)\n  InteractEvent = InteractEvent\n  Interactable: typeof InteractableBase\n  interactables = new InteractableSet(this)\n\n  // main window\n  _win!: Window\n\n  // main document\n  document!: Document\n\n  // main window\n  window!: Window\n\n  // all documents being listened to\n  documents: Array<{ doc: Document, options: any }> = []\n\n  _plugins: {\n    list: Plugin[]\n    map: { [id: string]: Plugin }\n  } = {\n    list: [],\n    map: {},\n  }\n\n  constructor () {\n    const scope = this\n\n    this.Interactable = class extends InteractableBase {\n      get _defaults () { return scope.defaults }\n\n      set <T extends InteractableBase> (this: T, options: Interact.OptionsArg) {\n        super.set(options)\n\n        scope.fire('interactable:set', {\n          options,\n          interactable: this,\n        })\n\n        return this\n      }\n\n      unset (this: InteractableBase) {\n        super.unset()\n        scope.interactables.list.splice(scope.interactables.list.indexOf(this), 1)\n\n        scope.fire('interactable:unset', { interactable: this })\n      }\n    }\n  }\n\n  addListeners (map: ListenerMap, id?: string) {\n    this.listenerMaps.push({ id, map })\n  }\n\n  fire<T extends ListenerName> (name: T, arg: SignalArgs[T]): void | false {\n    for (const { map: { [name]: listener } } of this.listenerMaps) {\n      if (!!listener && listener(arg as any, this, name as never) === false) {\n        return false\n      }\n    }\n  }\n\n  onWindowUnload = (event: BeforeUnloadEvent) => this.removeDocument(event.target as Document)\n\n  init (window: Window) {\n    return this.isInitialized\n      ? this\n      : initScope(this, window)\n  }\n\n  pluginIsInstalled (plugin: Plugin) {\n    return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1\n  }\n\n  usePlugin (plugin: Plugin, options?: { [key: string]: any }) {\n    if (!this.isInitialized) {\n      return this\n    }\n\n    if (this.pluginIsInstalled(plugin)) {\n      return this\n    }\n\n    if (plugin.id) { this._plugins.map[plugin.id] = plugin }\n    this._plugins.list.push(plugin)\n\n    if (plugin.install) {\n      plugin.install(this, options)\n    }\n\n    if (plugin.listeners && plugin.before) {\n      let index = 0\n      const len = this.listenerMaps.length\n      const before = plugin.before.reduce((acc, id) => {\n        acc[id] = true\n        acc[pluginIdRoot(id)] = true\n        return acc\n      }, {})\n\n      for (; index < len; index++) {\n        const otherId = this.listenerMaps[index].id\n\n        if (before[otherId] || before[pluginIdRoot(otherId)]) { break }\n      }\n\n      this.listenerMaps.splice(index, 0, { id: plugin.id, map: plugin.listeners })\n    }\n    else if (plugin.listeners) {\n      this.listenerMaps.push({ id: plugin.id, map: plugin.listeners })\n    }\n\n    return this\n  }\n\n  addDocument (doc: Document, options?: any): void | false {\n    // do nothing if document is already known\n    if (this.getDocIndex(doc) !== -1) { return false }\n\n    const window = win.getWindow(doc)\n\n    options = options ? extend({}, options) : {}\n\n    this.documents.push({ doc, options })\n    this.events.documents.push(doc)\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== this.document) {\n      this.events.add(window, 'unload', this.onWindowUnload)\n    }\n\n    this.fire('scope:add-document', { doc, window, scope: this, options })\n  }\n\n  removeDocument (doc: Document) {\n    const index = this.getDocIndex(doc)\n\n    const window = win.getWindow(doc)\n    const options = this.documents[index].options\n\n    this.events.remove(window, 'unload', this.onWindowUnload)\n\n    this.documents.splice(index, 1)\n    this.events.documents.splice(index, 1)\n\n    this.fire('scope:remove-document', { doc, window, scope: this, options })\n  }\n\n  getDocIndex (doc: Document) {\n    for (let i = 0; i < this.documents.length; i++) {\n      if (this.documents[i].doc === doc) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getDocOptions (doc: Document) {\n    const docIndex = this.getDocIndex(doc)\n\n    return docIndex === -1 ? null : this.documents[docIndex].options\n  }\n\n  now () {\n    return ((this.window as any).Date as typeof Date || Date).now()\n  }\n}\n\nexport function initScope (scope: Scope, window: Window) {\n  scope.isInitialized = true\n  win.init(window)\n  domObjects.init(window)\n  browser.init(window)\n  raf.init(window)\n\n  scope.window = window\n  scope.document = window.document\n\n  scope.usePlugin(interactions)\n  scope.usePlugin(events)\n\n  return scope\n}\n\nfunction pluginIdRoot (id: string) {\n  return id && id.replace(/\\/.*$/, '')\n}\n","import { Scope } from '@interactjs/core/scope'\n\nconst scope = new Scope()\n\nconst interact: import('@interactjs/core/interactStatic').InteractStatic = scope.interactStatic\n\nexport default interact\n\nexport const init = (win: Window) => scope.init(win)\n\nif (typeof window === 'object' && !!window) {\n  init(window)\n}\n","export default () => {}\n","export default () => {}\n","import * as Interact from '@interactjs/types/index'\n\nexport type GridOptions = (Partial<Interact.Rect> | Interact.Point) & {\n  range?: number\n  limits?: Interact.Rect\n  offset?: Interact.Point\n}\n\nexport default (grid: GridOptions) => {\n  const coordFields = ([\n    ['x', 'y'],\n    ['left', 'top'],\n    ['right', 'bottom'],\n    ['width', 'height'],\n  ] as const).filter(([xField, yField]) => xField in grid || yField in grid)\n\n  const gridFunc: Interact.SnapFunction & {\n    grid: typeof grid\n    coordFields: typeof coordFields\n  } = (x, y) => {\n    const {\n      range,\n      limits = {\n        left  : -Infinity,\n        right :  Infinity,\n        top   : -Infinity,\n        bottom:  Infinity,\n      },\n      offset = { x: 0, y: 0 },\n    } = grid\n\n    const result: Interact.SnapTarget & {\n      grid: typeof grid\n    } = { range, grid, x: null as number, y: null as number }\n\n    for (const [xField, yField] of coordFields) {\n      const gridx = Math.round((x - offset.x) / (grid as any)[xField])\n      const gridy = Math.round((y - offset.y) / (grid as any)[yField])\n\n      result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * (grid as any)[xField] + offset.x))\n      result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * (grid as any)[yField] + offset.y))\n    }\n\n    return result\n  }\n\n  gridFunc.grid = grid\n  gridFunc.coordFields = coordFields\n\n  return gridFunc\n}\n","import * as Interact from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\n\nimport * as allSnappers from './all'\n\ndeclare module '@interactjs/core/interactStatic' {\n  export interface InteractStatic {\n    snappers: typeof allSnappers\n    createSnapGrid: typeof allSnappers.grid\n  }\n}\n\nconst snappersPlugin: Interact.Plugin = {\n  id: 'snappers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    interact.snappers = extend(interact.snappers || {}, allSnappers)\n    interact.createSnapGrid = interact.snappers.grid\n  },\n}\n\nexport default snappersPlugin\n","/**\n * @module modifiers/aspectRatio\n *\n * @description\n * This module forces elements to be resized with a specified dx/dy ratio.\n *\n * @example\n * interact(target).resizable({\n *   modifiers: [\n *     interact.modifiers.snapSize({\n *       targets: [ interact.createSnapGrid({ x: 20, y: 20 }) ],\n *     }),\n *     interact.aspectRatio({ ratio: 'preserve' }),\n *   ],\n * });\n */\n\nimport * as Interact from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport { addEdges } from '@interactjs/utils/rect'\n\nimport Modification from './Modification'\nimport { Modifier, ModifierModule, ModifierState, makeModifier } from './base'\n\nexport interface AspectRatioOptions {\n  ratio?: number | 'preserve'\n  equalDelta?: boolean\n  modifiers?: Modifier[]\n  enabled?: boolean\n}\n\nexport type AspectRatioState = ModifierState<AspectRatioOptions, {\n  startCoords: Interact.Point\n  startRect: Interact.Rect\n  linkedEdges: Interact.EdgeOptions\n  ratio: number\n  equalDelta: boolean\n  xIsPrimaryAxis: boolean\n  edgeSign: 1 | -1\n  subModification: Modification\n}>\n\nconst aspectRatio: ModifierModule<AspectRatioOptions, AspectRatioState> = {\n  start (arg) {\n    const { state, rect, edges: originalEdges, pageCoords: coords } = arg\n    let { ratio } = state.options\n    const { equalDelta, modifiers } = state.options\n\n    if (ratio === 'preserve') {\n      ratio = rect.width / rect.height\n    }\n\n    state.startCoords = extend({}, coords)\n    state.startRect = extend({}, rect)\n    state.ratio = ratio\n    state.equalDelta = equalDelta\n\n    const linkedEdges = state.linkedEdges = {\n      top   : originalEdges.top    || (originalEdges.left   && !originalEdges.bottom),\n      left  : originalEdges.left   || (originalEdges.top    && !originalEdges.right),\n      bottom: originalEdges.bottom || (originalEdges.right  && !originalEdges.top),\n      right : originalEdges.right  || (originalEdges.bottom && !originalEdges.left),\n    }\n\n    state.xIsPrimaryAxis = !!(originalEdges.left || originalEdges.right)\n\n    if (state.equalDelta) {\n      state.edgeSign = (linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1) as 1 | -1\n    }\n    else {\n      const negativeSecondaryEdge = state.xIsPrimaryAxis ? linkedEdges.top : linkedEdges.left\n      state.edgeSign = negativeSecondaryEdge ? -1 : 1\n    }\n\n    extend(arg.edges, linkedEdges)\n\n    if (!modifiers || !modifiers.length) { return }\n\n    const subModification = new Modification(arg.interaction)\n\n    subModification.copyFrom(arg.interaction.modification)\n    subModification.prepareStates(modifiers)\n\n    state.subModification = subModification\n    subModification.startAll({ ...arg })\n  },\n\n  set (arg) {\n    const { state, rect, coords } = arg\n    const initialCoords = extend({}, coords)\n    const aspectMethod = state.equalDelta ? setEqualDelta : setRatio\n\n    aspectMethod(state, state.xIsPrimaryAxis, coords, rect)\n\n    if (!state.subModification) { return null }\n\n    const correctedRect = extend({}, rect)\n\n    addEdges(state.linkedEdges, correctedRect, { x: coords.x - initialCoords.x, y: coords.y - initialCoords.y })\n\n    const result = state.subModification.setAll({\n      ...arg,\n      rect: correctedRect,\n      edges: state.linkedEdges,\n      pageCoords: coords,\n      prevCoords: coords,\n      prevRect: correctedRect,\n    })\n\n    const { delta } = result\n\n    if (result.changed) {\n      const xIsCriticalAxis = Math.abs(delta.x) > Math.abs(delta.y)\n\n      // do aspect modification again with critical edge axis as primary\n      aspectMethod(state, xIsCriticalAxis, result.coords, result.rect)\n      extend(coords, result.coords)\n    }\n\n    return result.eventProps\n  },\n\n  defaults: {\n    ratio: 'preserve',\n    equalDelta: false,\n    modifiers: [],\n    enabled: false,\n  },\n}\n\nfunction setEqualDelta ({ startCoords, edgeSign }: AspectRatioState, xIsPrimaryAxis: boolean, coords: Interact.Point) {\n  if (xIsPrimaryAxis) {\n    coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign\n  }\n  else {\n    coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign\n  }\n}\n\nfunction setRatio ({ startRect, startCoords, ratio, edgeSign }: AspectRatioState, xIsPrimaryAxis: boolean, coords: Interact.Point, rect: Interact.Rect) {\n  if (xIsPrimaryAxis) {\n    const newHeight = rect.width / ratio\n\n    coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign\n  }\n  else {\n    const newWidth = rect.height * ratio\n\n    coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign\n  }\n}\n\nexport default makeModifier(aspectRatio, 'aspectRatio')\nexport { aspectRatio }\n","import { ModifierFunction } from './base'\n\nconst noop = (() => {\n}) as unknown as ModifierFunction<any, any, 'noop'>\n\nnoop._defaults = {}\n\nexport default noop\n","import * as Interact from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { makeModifier, ModifierArg, ModifierModule, ModifierState } from '../base'\n\nexport interface RestrictOptions {\n  // where to drag over\n  restriction: Interact.RectResolvable<[number, number, Interact.Interaction]>\n  // what part of self is allowed to drag over\n  elementRect: Interact.Rect\n  offset: Interact.Rect\n  // restrict just before the end drag\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictState = ModifierState<RestrictOptions, {\n  offset: Interact.Rect\n}>\n\nfunction start ({ rect, startOffset, state, interaction, pageCoords }: ModifierArg<RestrictState>) {\n  const { options } = state\n  const { elementRect } = options\n  const offset: Interact.Rect = extend({\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n  }, options.offset || {})\n\n  if (rect && elementRect) {\n    const restriction = getRestrictionRect(options.restriction, interaction, pageCoords)\n\n    if (restriction) {\n      const widthDiff = (restriction.right - restriction.left) - rect.width\n      const heightDiff = (restriction.bottom - restriction.top) - rect.height\n\n      if (widthDiff < 0) {\n        offset.left += widthDiff\n        offset.right += widthDiff\n      }\n      if (heightDiff < 0) {\n        offset.top += heightDiff\n        offset.bottom += heightDiff\n      }\n    }\n\n    offset.left += startOffset.left - (rect.width  * elementRect.left)\n    offset.top  += startOffset.top  - (rect.height * elementRect.top)\n\n    offset.right  += startOffset.right  - (rect.width  * (1 - elementRect.right))\n    offset.bottom += startOffset.bottom - (rect.height * (1 - elementRect.bottom))\n  }\n\n  state.offset = offset\n}\n\nfunction set ({ coords, interaction, state }: ModifierArg<RestrictState>) {\n  const { options, offset } = state\n\n  const restriction = getRestrictionRect(options.restriction, interaction, coords)\n\n  if (!restriction) { return }\n\n  const rect = rectUtils.xywhToTlbr(restriction)\n\n  coords.x = Math.max(Math.min(rect.right  - offset.right, coords.x), rect.left + offset.left)\n  coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top  + offset.top)\n}\n\nexport function getRestrictionRect (\n  value: Interact.RectResolvable<[number, number, Interact.Interaction]>,\n  interaction: Interact.Interaction,\n  coords?: Interact.Point,\n) {\n  if (is.func(value)) {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element, [coords.x, coords.y, interaction])\n  } else {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element)\n  }\n}\n\nconst defaults: RestrictOptions = {\n  restriction: null,\n  elementRect: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrict: ModifierModule<RestrictOptions, RestrictState> = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrict, 'restrict')\nexport { restrict }\n","// This module adds the options.resize.restrictEdges setting which sets min and\n// max for the top, left, bottom and right edges of the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictEdges: {\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\n//   },\n// })\n\nimport * as Interact from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { makeModifier, ModifierArg, ModifierState } from '../base'\n\nimport { getRestrictionRect, RestrictOptions } from './pointer'\n\nexport interface RestrictEdgesOptions {\n  inner: RestrictOptions['restriction']\n  outer: RestrictOptions['restriction']\n  offset?: RestrictOptions['offset']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictEdgesState = ModifierState<RestrictEdgesOptions, {\n  inner: Interact.Rect\n  outer: Interact.Rect\n  offset: RestrictEdgesOptions['offset']\n}>\n\nconst noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity }\nconst noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity }\n\nfunction start ({ interaction, startOffset, state }: ModifierArg<RestrictEdgesState>) {\n  const { options } = state\n  let offset\n\n  if (options) {\n    const offsetRect = getRestrictionRect(options.offset, interaction, interaction.coords.start.page)\n\n    offset = rectUtils.rectToXY(offsetRect)\n  }\n\n  offset = offset || { x: 0, y: 0 }\n\n  state.offset = {\n    top:    offset.y + startOffset.top,\n    left:   offset.x + startOffset.left,\n    bottom: offset.y - startOffset.bottom,\n    right:  offset.x - startOffset.right,\n  }\n}\n\nfunction set ({ coords, edges, interaction, state }: ModifierArg<RestrictEdgesState>) {\n  const { offset, options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const page = extend({}, coords)\n  const inner = getRestrictionRect(options.inner, interaction, page) || {} as Interact.Rect\n  const outer = getRestrictionRect(options.outer, interaction, page) || {} as Interact.Rect\n\n  fixRect(inner, noInner)\n  fixRect(outer, noOuter)\n\n  if (edges.top) {\n    coords.y = Math.min(Math.max(outer.top    + offset.top,    page.y), inner.top    + offset.top)\n  }\n  else if (edges.bottom) {\n    coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom)\n  }\n  if (edges.left) {\n    coords.x = Math.min(Math.max(outer.left   + offset.left,   page.x), inner.left   + offset.left)\n  }\n  else if (edges.right) {\n    coords.x = Math.max(Math.min(outer.right  + offset.right,  page.x), inner.right  + offset.right)\n  }\n}\n\nfunction fixRect (rect, defaults) {\n  for (const edge of ['top', 'left', 'bottom', 'right']) {\n    if (!(edge in rect)) {\n      rect[edge] = defaults[edge]\n    }\n  }\n\n  return rect\n}\n\nconst defaults: RestrictEdgesOptions = {\n  inner: null,\n  outer: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictEdges = {\n  noInner,\n  noOuter,\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictEdges, 'restrictEdges')\nexport { restrictEdges }\n","import extend from '@interactjs/utils/extend'\n\nimport { makeModifier } from '../base'\n\nimport { restrict } from './pointer'\n\nconst defaults = extend({\n  get elementRect () {\n    return { top: 0, left: 0, bottom: 1, right: 1 }\n  },\n  set elementRect (_) {},\n}, restrict.defaults)\n\nconst restrictRect = {\n  start: restrict.start,\n  set: restrict.set,\n  defaults,\n}\n\nexport default makeModifier(restrictRect, 'restrictRect')\nexport { restrictRect }\n","import * as Interact from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { makeModifier, ModifierArg, ModifierState } from '../base'\n\nimport { restrictEdges, RestrictEdgesState } from './edges'\nimport { getRestrictionRect, RestrictOptions } from './pointer'\n\nconst noMin = { width: -Infinity, height: -Infinity }\nconst noMax = { width: +Infinity, height: +Infinity }\n\nexport interface RestrictSizeOptions {\n  min?: Interact.Size | Interact.Point | RestrictOptions['restriction']\n  max?: Interact.Size | Interact.Point | RestrictOptions['restriction']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nfunction start (arg: ModifierArg<RestrictEdgesState>) {\n  return restrictEdges.start(arg)\n}\n\nexport type RestrictSizeState =\n  RestrictEdgesState & ModifierState<RestrictSizeOptions & { inner: Interact.Rect, outer: Interact.Rect }, {\n    min: Interact.Rect\n    max: Interact.Rect\n  }>\n\nfunction set (arg: ModifierArg<RestrictSizeState>) {\n  const { interaction, state, rect, edges } = arg\n  const { options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const minSize = rectUtils.tlbrToXywh(getRestrictionRect(options.min as any, interaction, arg.coords)) || noMin\n  const maxSize = rectUtils.tlbrToXywh(getRestrictionRect(options.max as any, interaction, arg.coords)) || noMax\n\n  state.options = {\n    endOnly: options.endOnly,\n    inner: extend({}, restrictEdges.noInner),\n    outer: extend({}, restrictEdges.noOuter),\n  }\n\n  if (edges.top) {\n    state.options.inner.top = rect.bottom - minSize.height\n    state.options.outer.top = rect.bottom - maxSize.height\n  }\n  else if (edges.bottom) {\n    state.options.inner.bottom = rect.top + minSize.height\n    state.options.outer.bottom = rect.top + maxSize.height\n  }\n  if (edges.left) {\n    state.options.inner.left = rect.right - minSize.width\n    state.options.outer.left = rect.right - maxSize.width\n  }\n  else if (edges.right) {\n    state.options.inner.right = rect.left + minSize.width\n    state.options.outer.right = rect.left + maxSize.width\n  }\n\n  restrictEdges.set(arg)\n\n  state.options = options\n}\n\nconst defaults: RestrictSizeOptions = {\n  min: null,\n  max: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictSize, 'restrictSize')\nexport { restrictSize }\n","import * as Interact from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { resolveRectLike, rectToXY } from '@interactjs/utils/rect'\n\nimport { makeModifier, ModifierArg, ModifierState } from '../base'\n\nexport interface Offset {\n  x: number\n  y: number\n  index: number\n  relativePoint?: Interact.Point\n}\n\nexport interface SnapPosition {\n  x?: number\n  y?: number\n  range?: number\n  offset?: Offset\n  [index: string]: any\n}\n\nexport type SnapFunction = (\n  x: number,\n  y: number,\n  interaction: Interact.InteractionProxy,\n  offset: Offset,\n  index: number\n) => SnapPosition\nexport type SnapTarget = SnapPosition | SnapFunction\nexport interface SnapOptions {\n  targets: SnapTarget[]\n  // target range\n  range: number\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\n  relativePoints: Interact.Point[]\n  // startCoords = offset snapping from drag start page position\n  offset: Interact.Point | Interact.RectResolvable<[Interact.Interaction]> | 'startCoords'\n  offsetWithOrigin?: boolean\n  origin: Interact.RectResolvable<[Interact.Element]> | Interact.Point\n  endOnly?: boolean\n  enabled?: boolean\n}\n\nexport type SnapState = ModifierState<SnapOptions, {\n  offsets?: Offset[]\n  closest?: any\n  targetFields?: string[][]\n}>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { interaction, interactable, element, rect, state, startOffset } = arg\n  const { options } = state\n  const origin = options.offsetWithOrigin\n    ? getOrigin(arg)\n    : { x: 0, y: 0 }\n\n  let snapOffset: Interact.Point\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x,\n      y: interaction.coords.start.page.y,\n    }\n  }\n  else  {\n    const offsetRect = resolveRectLike(options.offset as any, interactable, element, [interaction])\n\n    snapOffset = rectToXY(offsetRect) || { x: 0, y: 0 }\n    snapOffset.x += origin.x\n    snapOffset.y += origin.y\n  }\n\n  const { relativePoints } = options\n\n  state.offsets = rect && relativePoints && relativePoints.length\n    ?  relativePoints.map((relativePoint, index) => ({\n      index,\n      relativePoint,\n      x: startOffset.left - (rect.width  * relativePoint.x) + snapOffset.x,\n      y: startOffset.top  - (rect.height * relativePoint.y) + snapOffset.y,\n    }))\n    : [extend({\n      index: 0,\n      relativePoint: null,\n    }, snapOffset)]\n}\n\nfunction set (arg: ModifierArg<SnapState>) {\n  const { interaction, coords, state } = arg\n  const { options, offsets } = state\n\n  const origin = getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name)\n  const page = extend({}, coords)\n  const targets = []\n\n  if (!options.offsetWithOrigin) {\n    page.x -= origin.x\n    page.y -= origin.y\n  }\n\n  for (const offset of offsets) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0, len = options.targets.length; index < len; index++) {\n      const snapTarget = options.targets[index]\n      let target: SnapPosition\n\n      if (is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index)\n      }\n      else {\n        target = snapTarget\n      }\n\n      if (!target) { continue }\n\n      targets.push({\n        x: (is.number(target.x) ? target.x : relativeX) + offset.x,\n        y: (is.number(target.y) ? target.y : relativeY) + offset.y,\n\n        range: is.number(target.range) ? target.range : options.range,\n        source: snapTarget,\n        index,\n        offset,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    delta: { x: 0, y: 0 },\n  }\n\n  for (const target of targets) {\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = hypot(dx, dy)\n    let inRange = distance <= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (!closest.target || (inRange\n      // is the closest target in range?\n      ? (closest.inRange && range !== Infinity\n        // the pointer is relatively deeper in this target\n        ? distance / range < closest.distance / closest.range\n        // this target has Infinite range and the closest doesn't\n        : (range === Infinity && closest.range !== Infinity) ||\n          // OR this target is closer that the previous closest\n          distance < closest.distance)\n      // The other is not in range and the pointer is closer to this target\n      : (!closest.inRange && distance < closest.distance))) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.delta.x = dx\n      closest.delta.y = dy\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n  return closest\n}\n\nfunction getOrigin (arg: Partial<ModifierArg<SnapState>>) {\n  const { element } = arg.interaction\n  const optionsOrigin = rectToXY(\n    resolveRectLike(arg.state.options.origin as any, null, null, [element]),\n  )\n  const origin = optionsOrigin || getOriginXY(\n    arg.interactable,\n    element,\n    arg.interaction.prepared.name,\n  )\n\n  return origin\n}\n\nconst defaults: SnapOptions = {\n  range  : Infinity,\n  targets: null,\n  offset: null,\n  offsetWithOrigin: true,\n  origin: null,\n  relativePoints: null,\n  endOnly: false,\n  enabled: false,\n}\nconst snap = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snap, 'snap')\nexport { snap }\n","// This module allows snapping of the size of targets during resize\n// interactions.\n\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nimport { makeModifier, ModifierArg } from '../base'\n\nimport { snap, SnapOptions, SnapState } from './pointer'\n\nexport type SnapSizeOptions = Pick<\nSnapOptions,\n'targets' | 'offset' | 'endOnly' | 'range' | 'enabled'\n>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { state, edges } = arg\n  const { options } = state\n\n  if (!edges) { return null }\n\n  arg.state = {\n    options: {\n      targets: null,\n      relativePoints: [{\n        x: edges.left ? 0 : 1,\n        y: edges.top ? 0 : 1,\n      }],\n      offset: options.offset || 'self',\n      origin: { x: 0, y: 0 },\n      range: options.range,\n    },\n  }\n\n  state.targetFields = state.targetFields || [\n    ['width', 'height'],\n    ['x', 'y'],\n  ]\n\n  snap.start(arg)\n  state.offsets = arg.state.offsets\n\n  arg.state = state\n}\n\nfunction set (arg) {\n  const { interaction, state, coords } = arg\n  const { options, offsets } = state\n  const relative = {\n    x: coords.x - offsets[0].x,\n    y: coords.y - offsets[0].y,\n  }\n\n  state.options = extend({}, options)\n  state.options.targets = []\n\n  for (const snapTarget of (options.targets || [])) {\n    let target\n\n    if (is.func(snapTarget)) {\n      target = snapTarget(relative.x, relative.y, interaction)\n    }\n    else {\n      target = snapTarget\n    }\n\n    if (!target) { continue }\n\n    for (const [xField, yField] of state.targetFields) {\n      if (xField in target || yField in target) {\n        target.x = target[xField]\n        target.y = target[yField]\n\n        break\n      }\n    }\n\n    state.options.targets.push(target)\n  }\n\n  const returnValue = snap.set(arg)\n\n  state.options = options\n\n  return returnValue\n}\n\nconst defaults: SnapSizeOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst snapSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snapSize, 'snapSize')\nexport { snapSize }\n","/**\n * @module modifiers/snapEdges\n *\n * @description\n * This module allows snapping of the edges of targets during resize\n * interactions.\n *\n * @example\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [interact.snappers.grid({ x: 100, y: 50 })],\n *   },\n * })\n *\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [\n *       interact.snappers.grid({\n *        top: 50,\n *        left: 50,\n *        bottom: 100,\n *        right: 100,\n *       }),\n *     ],\n *   },\n * })\n */\n\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\n\nimport { makeModifier, ModifierArg, ModifierModule } from '../base'\n\nimport { SnapOptions, SnapState } from './pointer'\nimport { snapSize } from './size'\n\nexport type SnapEdgesOptions = Pick<SnapOptions, 'targets' | 'range' | 'offset' | 'endOnly' | 'enabled'>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { edges } = arg\n\n  if (!edges) { return null }\n\n  arg.state.targetFields = arg.state.targetFields || [\n    [edges.left ? 'left' : 'right', edges.top ? 'top' : 'bottom'],\n  ]\n\n  return snapSize.start(arg)\n}\n\nconst snapEdges: ModifierModule<SnapEdgesOptions, SnapState> = {\n  start,\n  set: snapSize.set,\n  defaults: extend(\n    clone(snapSize.defaults),\n    {\n      targets: null,\n      range: null,\n      offset: { x: 0, y: 0 },\n    } as const,\n  ),\n}\n\nexport default makeModifier(snapEdges, 'snapEdges')\nexport { snapEdges }\n","/* eslint-disable node/no-extraneous-import */\nimport aspectRatio from './aspectRatio'\nimport avoid from './avoid'\nimport restrictEdges from './restrict/edges'\nimport restrict from './restrict/pointer'\nimport restrictRect from './restrict/rect'\nimport restrictSize from './restrict/size'\nimport rubberband from './rubberband'\nimport snapEdges from './snap/edges'\nimport snap from './snap/pointer'\nimport snapSize from './snap/size'\nimport spring from './spring'\nimport transform from './transform'\n\nexport default {\n  aspectRatio,\n  restrictEdges,\n  restrict,\n  restrictRect,\n  restrictSize,\n  snapEdges,\n  snap,\n  snapSize,\n\n  spring,\n  avoid,\n  transform,\n  rubberband,\n}\n","import snappers from '@interactjs/snappers/plugin'\nimport * as Interact from '@interactjs/types/index'\n\nimport all from './all'\nimport base from './base'\n\ndeclare module '@interactjs/core/interactStatic' {\n  export interface InteractStatic {\n    modifiers: typeof all\n  }\n}\n\nconst modifiers: Interact.Plugin = {\n  id: 'modifiers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    scope.usePlugin(base)\n    scope.usePlugin(snappers)\n\n    interact.modifiers = all\n\n    // for backwrads compatibility\n    for (const type in all) {\n      const { _defaults, _methods } = all[type as keyof typeof all]\n\n      ;(_defaults as any)._methods = _methods\n      ;(scope.defaults.perAction as any)[type] = _defaults\n    }\n  },\n}\n\nexport default modifiers\n","import * as Interact from '@interactjs/types/index'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport { BaseEvent } from '../core/BaseEvent'\n\nexport default class PointerEvent<T extends string = any> extends BaseEvent {\n  type: T\n  originalEvent: Interact.PointerEventType\n  pointerId: number\n  pointerType: string\n  double: boolean\n  pageX: number\n  pageY: number\n  clientX: number\n  clientY: number\n  dt: number\n  eventable: any\n  [key: string]: any\n\n  /** */\n  constructor (\n    type: T,\n    pointer: Interact.PointerType | PointerEvent<any>,\n    event: Interact.PointerEventType,\n    eventTarget: Node,\n    interaction: Interact.Interaction,\n    timeStamp: number,\n  ) {\n    super(interaction)\n    pointerUtils.pointerExtend(this, event)\n\n    if (event !== pointer) {\n      pointerUtils.pointerExtend(this, pointer)\n    }\n\n    this.timeStamp     = timeStamp\n    this.originalEvent = event\n    this.type          = type\n    this.pointerId     = pointerUtils.getPointerId(pointer)\n    this.pointerType   = pointerUtils.getPointerType(pointer)\n    this.target        = eventTarget\n    this.currentTarget = null\n\n    if (type === 'tap') {\n      const pointerIndex = interaction.getPointerIndex(pointer)\n      this.dt = this.timeStamp - interaction.pointers[pointerIndex].downTime\n\n      const interval = this.timeStamp - interaction.tapTime\n\n      this.double = !!(interaction.prevTap &&\n        interaction.prevTap.type !== 'doubletap' &&\n        interaction.prevTap.target === this.target &&\n        interval < 500)\n    }\n    else if (type === 'doubletap') {\n      this.dt = (pointer as PointerEvent<'tap'>).timeStamp - interaction.tapTime\n    }\n  }\n\n  _subtractOrigin ({ x: originX, y: originY }: Interact.Point) {\n    this.pageX   -= originX\n    this.pageY   -= originY\n    this.clientX -= originX\n    this.clientY -= originY\n\n    return this\n  }\n\n  _addOrigin ({ x: originX, y: originY }: Interact.Point) {\n    this.pageX   += originX\n    this.pageY   += originY\n    this.clientX += originX\n    this.clientY += originY\n\n    return this\n  }\n\n  /**\n   * Prevent the default behaviour of the original Event\n   */\n  preventDefault () {\n    this.originalEvent.preventDefault()\n  }\n}\n\nexport { PointerEvent }\n","import { Eventable } from '@interactjs/core/Eventable'\nimport { Interaction } from '@interactjs/core/Interaction'\nimport { PerActionDefaults } from '@interactjs/core/defaultOptions'\nimport { Scope } from '@interactjs/core/scope'\nimport * as Interact from '@interactjs/types/index'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\n\nimport { PointerEvent } from './PointerEvent'\n\nexport type EventTargetList = Array<{\n  node: Node\n  eventable: Eventable\n  props: { [key: string]: any }\n}>\n\nexport interface PointerEventOptions extends PerActionDefaults {\n  enabled?: undefined // not used\n  holdDuration?: number\n  ignoreFrom?: any\n  allowFrom?: any\n  origin?: Interact.Point | string | Interact.Element\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    pointerEvents: typeof pointerEvents\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    prevTap?: PointerEvent<string>\n    tapTime?: number\n  }\n}\n\ndeclare module '@interactjs/core/PointerInfo' {\n  interface PointerInfo {\n    hold?: {\n      duration: number\n      timeout: any\n    }\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    pointerEvents: Interact.Options\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'pointerEvents:new': { pointerEvent: PointerEvent<any> }\n    'pointerEvents:fired': {\n      interaction: Interaction\n      pointer: Interact.PointerType | PointerEvent<any>\n      event: Interact.PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      pointerEvent: PointerEvent<any>\n      targets?: EventTargetList\n      type: string\n    }\n    'pointerEvents:collect-targets': {\n      interaction: Interaction\n      pointer: Interact.PointerType | PointerEvent<any>\n      event: Interact.PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      targets?: EventTargetList\n      type: string\n      path: Node[]\n      node: null\n    }\n  }\n}\n\nconst defaults: PointerEventOptions = {\n  holdDuration: 600,\n  ignoreFrom  : null,\n  allowFrom   : null,\n  origin      : { x: 0, y: 0 },\n}\n\nconst pointerEvents: Interact.Plugin = {\n  id: 'pointer-events/base',\n  before: ['inertia', 'modifiers', 'auto-start', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': addInteractionProps,\n    'interactions:update-pointer': addHoldInfo,\n    'interactions:move': moveAndClearHold,\n    'interactions:down': (arg, scope) => {\n      downAndStartHold(arg, scope)\n      fire(arg, scope)\n    },\n    'interactions:up': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n      tapAfterUp(arg, scope)\n    },\n    'interactions:cancel': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n    },\n  },\n  PointerEvent,\n  fire,\n  collectEventTargets,\n  defaults,\n  types: {\n    down: true,\n    move: true,\n    up: true,\n    cancel: true,\n    tap: true,\n    doubletap: true,\n    hold: true,\n  } as { [type: string]: true },\n}\n\nfunction fire<T extends string> (\n  arg: {\n    pointer: Interact.PointerType | PointerEvent<any>\n    event: Interact.PointerEventType | PointerEvent<any>\n    eventTarget: Node\n    interaction: Interaction\n    type: T\n    targets?: EventTargetList\n  },\n  scope: Interact.Scope,\n) {\n  const {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    targets = collectEventTargets(arg, scope),\n  } = arg\n\n  const pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction, scope.now())\n\n  scope.fire('pointerEvents:new', { pointerEvent })\n\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n    type,\n    pointerEvent,\n  }\n\n  for (let i = 0; i < targets.length; i++) {\n    const target = targets[i]\n\n    for (const prop in target.props || {}) {\n      (pointerEvent as any)[prop] = target.props[prop]\n    }\n\n    const origin = getOriginXY(target.eventable, target.node)\n\n    pointerEvent._subtractOrigin(origin)\n    pointerEvent.eventable = target.eventable\n    pointerEvent.currentTarget = target.node\n\n    target.eventable.fire(pointerEvent)\n\n    pointerEvent._addOrigin(origin)\n\n    if (pointerEvent.immediatePropagationStopped ||\n        (pointerEvent.propagationStopped &&\n            (i + 1) < targets.length && targets[i + 1].node !== pointerEvent.currentTarget)) {\n      break\n    }\n  }\n\n  scope.fire('pointerEvents:fired', signalArg)\n\n  if (type === 'tap') {\n    // if pointerEvent should make a double tap, create and fire a doubletap\n    // PointerEvent and use that as the prevTap\n    const prevTap = pointerEvent.double\n      ? fire({\n        interaction,\n        pointer,\n        event,\n        eventTarget,\n        type: 'doubletap',\n      }, scope)\n      : pointerEvent\n\n    interaction.prevTap = prevTap\n    interaction.tapTime = prevTap.timeStamp\n  }\n\n  return pointerEvent\n}\n\nfunction collectEventTargets<T extends string> ({ interaction, pointer, event, eventTarget, type }: {\n  interaction: Interaction\n  pointer: Interact.PointerType | PointerEvent<any>\n  event: Interact.PointerEventType | PointerEvent<any>\n  eventTarget: Node\n  type: T\n}, scope: Interact.Scope) {\n  const pointerIndex = interaction.getPointerIndex(pointer)\n  const pointerInfo = interaction.pointers[pointerIndex]\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (type === 'tap' && (interaction.pointerWasMoved ||\n      // or if the pointerup target is different to the pointerdown target\n      !(pointerInfo && pointerInfo.downTarget === eventTarget))) {\n    return []\n  }\n\n  const path = domUtils.getPath(eventTarget as Interact.Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    path,\n    targets: [] as EventTargetList,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (type === 'hold') {\n    signalArg.targets = signalArg.targets.filter(target =>\n      target.eventable.options.holdDuration === interaction.pointers[pointerIndex].hold.duration)\n  }\n\n  return signalArg.targets\n}\n\nfunction addInteractionProps ({ interaction }) {\n  interaction.prevTap = null   // the most recent tap event on this interaction\n  interaction.tapTime = 0     // time of the most recent tap event\n}\n\nfunction addHoldInfo ({ down, pointerInfo }: Interact.SignalArgs['interactions:update-pointer']) {\n  if (!down && pointerInfo.hold) {\n    return\n  }\n\n  pointerInfo.hold = { duration: Infinity, timeout: null }\n}\n\nfunction clearHold ({ interaction, pointerIndex }) {\n  const hold = interaction.pointers[pointerIndex].hold\n\n  if (hold && hold.timeout) {\n    clearTimeout(hold.timeout)\n    hold.timeout = null\n  }\n}\n\nfunction moveAndClearHold (\n  arg: Interact.SignalArgs['interactions:move'],\n  scope: Interact.Scope,\n) {\n  const { interaction, pointer, event, eventTarget, duplicate } = arg\n\n  if (!duplicate && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearHold(arg)\n    }\n\n    fire({\n      interaction,\n      pointer,\n      event,\n      eventTarget: eventTarget as Interact.Element,\n      type: 'move',\n    }, scope)\n  }\n}\n\nfunction downAndStartHold ({ interaction, pointer, event, eventTarget, pointerIndex }: Interact.SignalArgs['interactions:down'], scope: Interact.Scope) {\n  const timer = interaction.pointers[pointerIndex].hold\n  const path = domUtils.getPath(eventTarget as Interact.Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type: 'hold',\n    targets: [] as EventTargetList,\n    path,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (!signalArg.targets.length) { return }\n\n  let minDuration = Infinity\n\n  for (const target of signalArg.targets) {\n    const holdDuration = target.eventable.options.holdDuration\n\n    if (holdDuration < minDuration) {\n      minDuration = holdDuration\n    }\n  }\n\n  timer.duration = minDuration\n  timer.timeout = setTimeout(() => {\n    fire({\n      interaction,\n      eventTarget,\n      pointer,\n      event,\n      type: 'hold',\n    }, scope)\n  }, minDuration)\n}\n\nfunction tapAfterUp ({ interaction, pointer, event, eventTarget }: Interact.SignalArgs['interactions:up'], scope: Interact.Scope) {\n  if (!interaction.pointerWasMoved) {\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' }, scope)\n  }\n}\n\nfunction install (scope: Scope) {\n  scope.pointerEvents = pointerEvents\n  scope.defaults.actions.pointerEvents = pointerEvents.defaults\n  extend(scope.actions.phaselessTypes, pointerEvents.types)\n}\n\nexport default pointerEvents\n","import { ListenerMap } from '@interactjs/core/scope'\nimport * as Interact from '@interactjs/types/index'\n\nimport PointerEvent from './PointerEvent'\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    holdIntervalHandle?: any\n  }\n}\n\ndeclare module '@interactjs/pointer-events/PointerEvent' {\n  interface PointerEvent<T extends string = any> {\n    count?: number\n  }\n}\n\ndeclare module '@interactjs/pointer-events/base' {\n  interface PointerEventOptions {\n    holdRepeatInterval?: number\n  }\n}\n\nfunction install (scope: Interact.Scope) {\n  scope.usePlugin(basePlugin)\n\n  const {\n    pointerEvents,\n  } = scope\n\n  // don't repeat by default\n  pointerEvents.defaults.holdRepeatInterval = 0\n  pointerEvents.types.holdrepeat = scope.actions.phaselessTypes.holdrepeat = true\n}\n\nfunction onNew ({ pointerEvent }: { pointerEvent: PointerEvent<any> }) {\n  if (pointerEvent.type !== 'hold') { return }\n\n  pointerEvent.count = (pointerEvent.count || 0) + 1\n}\n\nfunction onFired (\n  { interaction, pointerEvent, eventTarget, targets }: Interact.SignalArgs['pointerEvents:fired'],\n  scope: Interact.Scope,\n) {\n  if (pointerEvent.type !== 'hold' || !targets.length) { return }\n\n  // get the repeat interval from the first eventable\n  const interval = targets[0].eventable.options.holdRepeatInterval\n\n  // don't repeat if the interval is 0 or less\n  if (interval <= 0) { return }\n\n  // set a timeout to fire the holdrepeat event\n  interaction.holdIntervalHandle = setTimeout(() => {\n    scope.pointerEvents.fire({\n      interaction,\n      eventTarget,\n      type: 'hold',\n      pointer: pointerEvent,\n      event: pointerEvent,\n    }, scope)\n  }, interval)\n}\n\nfunction endHoldRepeat ({ interaction }: { interaction: Interact.Interaction }) {\n  // set the interaction's holdStopTime property\n  // to stop further holdRepeat events\n  if (interaction.holdIntervalHandle) {\n    clearInterval(interaction.holdIntervalHandle)\n    interaction.holdIntervalHandle = null\n  }\n}\n\nconst holdRepeat: Interact.Plugin = {\n  id: 'pointer-events/holdRepeat',\n  install,\n  listeners: ['move', 'up', 'cancel', 'endall'].reduce(\n    (acc, enderTypes) => {\n      (acc as any)[`pointerEvents:${enderTypes}`] = endHoldRepeat\n      return acc\n    },\n    {\n      'pointerEvents:new': onNew,\n      'pointerEvents:fired': onFired,\n    } as ListenerMap,\n  ),\n}\n\nexport default holdRepeat\n","import * as Interact from '@interactjs/types/index'\nimport extend from '@interactjs/utils/extend'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    pointerEvents: typeof pointerEventsMethod\n    __backCompatOption: (optionName: string, newValue: any) => any\n  }\n}\n\nfunction install (scope: Interact.Scope) {\n  const { Interactable } = scope\n\n  Interactable.prototype.pointerEvents = pointerEventsMethod\n\n  const __backCompatOption = Interactable.prototype._backCompatOption\n\n  Interactable.prototype._backCompatOption = function (optionName, newValue) {\n    const ret = __backCompatOption.call(this, optionName, newValue)\n\n    if (ret === this) {\n      this.events.options[optionName] = newValue\n    }\n\n    return ret\n  }\n}\n\nfunction pointerEventsMethod (this: Interact.Interactable, options: any) {\n  extend(this.events.options, options)\n\n  return this\n}\n\nconst plugin: Interact.Plugin = {\n  id: 'pointer-events/interactableTargets',\n  install,\n  listeners: {\n    'pointerEvents:collect-targets': ({\n      targets,\n      node,\n      type,\n      eventTarget,\n    }, scope) => {\n      scope.interactables.forEachMatch(node, (interactable: Interact.Interactable) => {\n        const eventable = interactable.events\n        const options = eventable.options\n\n        if (\n          eventable.types[type] &&\n          eventable.types[type].length &&\n        interactable.testIgnoreAllow(options, node, eventTarget)) {\n          targets.push({\n            node,\n            eventable,\n            props: { interactable },\n          })\n        }\n      })\n    },\n\n    'interactable:new': ({ interactable }) => {\n      interactable.events.getRect = function (element: Interact.Element) {\n        return interactable.getRect(element)\n      }\n    },\n\n    'interactable:set': ({ interactable, options }, scope) => {\n      extend(interactable.events.options, scope.pointerEvents.defaults)\n      extend(interactable.events.options, options.pointerEvents || {})\n    },\n  },\n}\n\nexport default plugin\n","import * as Interact from '@interactjs/types/index'\n\nimport * as pointerEvents from './base'\nimport holdRepeat from './holdRepeat'\nimport interactableTargets from './interactableTargets'\n\nconst plugin: Interact.Plugin = {\n  id: 'pointer-events',\n  install (scope) {\n    scope.usePlugin(pointerEvents)\n    scope.usePlugin(holdRepeat)\n    scope.usePlugin(interactableTargets)\n  },\n}\n\nexport default plugin\n","import { Interactable } from '@interactjs/core/Interactable'\nimport { ActionProps, Interaction } from '@interactjs/core/Interaction'\nimport { Scope } from '@interactjs/core/scope'\nimport * as Interact from '@interactjs/types/index'\nimport * as arr from '@interactjs/utils/arr'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport { tlbrToXywh } from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-reflow': Omit<Interact.DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-reflow': Interact.DoAnyPhaseArg\n    'interactions:after-action-reflow': Interact.DoAnyPhaseArg\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    reflow: (action: ActionProps) => ReturnType<typeof reflow>\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    _reflowPromise: Promise<void>\n    _reflowResolve: () => void\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  // eslint-disable-next-line no-shadow\n  interface PhaseMap {\n    reflow?: true\n  }\n}\n\nexport function install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    // eslint-disable-next-line no-shadow\n    Interactable,\n  } = scope\n\n  scope.actions.phases.reflow = true\n\n  /**\n   * ```js\n   * const interactable = interact(target)\n   * const drag = { name: drag, axis: 'x' }\n   * const resize = { name: resize, edges: { left: true, bottom: true }\n   *\n   * interactable.reflow(drag)\n   * interactable.reflow(resize)\n   * ```\n   *\n   * Start an action sequence to re-apply modifiers, check drops, etc.\n   *\n   * @param { Object } action The action to begin\n   * @param { string } action.name The name of the action\n   * @returns { Promise } A promise that resolves to the `Interactable` when actions on all targets have ended\n   */\n  Interactable.prototype.reflow = function (action: ActionProps) {\n    return reflow(this, action, scope)\n  }\n}\n\nfunction reflow<T extends Interact.ActionName> (interactable: Interactable, action: ActionProps<T>, scope: Scope): Promise<Interactable> {\n  const elements = (is.string(interactable.target)\n    ? arr.from(interactable._context.querySelectorAll(interactable.target))\n    : [interactable.target]) as Interact.Element[]\n\n  // tslint:disable-next-line variable-name\n  const Promise = (scope.window as any).Promise\n  const promises: Array<Promise<null>> | null = Promise ? [] : null\n\n  for (const element of elements) {\n    const rect = interactable.getRect(element as HTMLElement | SVGElement)\n\n    if (!rect) { break }\n\n    const runningInteraction = arr.find(\n      scope.interactions.list,\n      (interaction: Interaction) => {\n        return interaction.interacting() &&\n          interaction.interactable === interactable &&\n          interaction.element === element &&\n          interaction.prepared.name === action.name\n      })\n    let reflowPromise: Promise<null>\n\n    if (runningInteraction) {\n      runningInteraction.move()\n\n      if (promises) {\n        reflowPromise = runningInteraction._reflowPromise || new Promise((resolve: any) => {\n          runningInteraction._reflowResolve = resolve\n        })\n      }\n    }\n    else {\n      const xywh = tlbrToXywh(rect)\n      const coords = {\n        page     : { x: xywh.x, y: xywh.y },\n        client   : { x: xywh.x, y: xywh.y },\n        timeStamp: scope.now(),\n      }\n\n      const event = pointerUtils.coordsToEvent(coords)\n      reflowPromise = startReflow<T>(scope, interactable, element, action, event)\n    }\n\n    if (promises) {\n      promises.push(reflowPromise)\n    }\n  }\n\n  return promises && Promise.all(promises).then(() => interactable)\n}\n\nfunction startReflow<T extends Interact.ActionName> (scope: Scope, interactable: Interactable, element: Interact.Element, action: ActionProps<T>, event: any) {\n  const interaction = scope.interactions.new({ pointerType: 'reflow' })\n  const signalArg = {\n    interaction,\n    event,\n    pointer: event,\n    eventTarget: element,\n    phase: 'reflow',\n  } as const\n\n  interaction.interactable = interactable\n  interaction.element = element\n  interaction.prevEvent = event\n  interaction.updatePointer(event, event, element, true)\n  pointerUtils.setZeroCoords(interaction.coords.delta)\n\n  copyAction(interaction.prepared, action)\n  interaction._doPhase(signalArg)\n\n  const { Promise } = (scope.window as unknown as { Promise: PromiseConstructor })\n  const reflowPromise = Promise\n    ? new Promise<undefined>(resolve => {\n      interaction._reflowResolve = resolve\n    })\n    : undefined\n\n  interaction._reflowPromise = reflowPromise\n  interaction.start(action, interactable, element)\n\n  if (interaction._interacting) {\n    interaction.move(signalArg)\n    interaction.end(event)\n  }\n  else {\n    interaction.stop()\n    interaction._reflowResolve()\n  }\n\n  interaction.removePointer(event, event)\n\n  return reflowPromise\n}\n\nexport default {\n  id: 'reflow',\n  install,\n  listeners: {\n    // remove completed reflow interactions\n    'interactions:stop': ({ interaction }, scope) => {\n      if (interaction.pointerType === 'reflow') {\n        if (interaction._reflowResolve) {\n          interaction._reflowResolve()\n        }\n\n        arr.remove(scope.interactions.list, interaction)\n      }\n    },\n  },\n} as Interact.Plugin\n","export default {}\n","export const exchange = {}\n","import actions from '@interactjs/actions/plugin'\nimport arrange from '@interactjs/arrange/plugin'\nimport autoScroll from '@interactjs/auto-scroll/plugin'\nimport autoStart from '@interactjs/auto-start/plugin'\nimport clone from '@interactjs/clone/plugin'\nimport interactablePreventDefault from '@interactjs/core/interactablePreventDefault'\nimport devTools from '@interactjs/dev-tools/plugin'\nimport feedback from '@interactjs/feedback/plugin'\nimport inertia from '@interactjs/inertia/plugin'\nimport interact from '@interactjs/interact'\nimport modifiers from '@interactjs/modifiers/plugin'\nimport multiTarget from '@interactjs/multi-target/plugin'\nimport offset from '@interactjs/offset/plugin'\nimport pointerEvents from '@interactjs/pointer-events/plugin'\nimport reactComponents from '@interactjs/react/plugin'\nimport reflow from '@interactjs/reflow/plugin'\nimport * as displace from '@interactjs/utils/displace'\nimport { exchange } from '@interactjs/utils/exchange'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport vueComponents from '@interactjs/vue/plugin'\n\ndeclare module '@interactjs/core/interactStatic' {\n  export interface InteractStatic {\n    __utils: {\n      exchange: typeof exchange\n      displace: typeof displace\n      pointer: typeof pointerUtils\n    }\n  }\n}\n\ninteract.use(multiTarget)\n\ninteract.use(interactablePreventDefault)\n\ninteract.use(offset)\n\n// interaction element cloning\ninteract.use(clone)\n\n// sortable and swappable\ninteract.use(arrange)\n\n// pointerEvents\ninteract.use(pointerEvents)\n\n// inertia\ninteract.use(inertia)\n\n// snap, resize, etc.\ninteract.use(modifiers)\n\n// autoStart, hold\ninteract.use(autoStart)\n\n// drag and drop, resize, gesture\ninteract.use(actions)\n\n// autoScroll\ninteract.use(autoScroll)\n\n// reflow\ninteract.use(reflow)\n\ninteract.use(feedback)\n\ninteract.use(vueComponents)\n\ninteract.use(reactComponents)\n\ninteract.__utils = {\n  exchange,\n  displace,\n  pointer: pointerUtils,\n}\n\n// eslint-disable-next-line no-undef\nif (process.env.NODE_ENV !== 'production') {\n  interact.use(devTools)\n}\n\nexport default interact\n\nif (typeof module === 'object' && !!module) {\n  try { module.exports = interact }\n  catch {}\n}\n\n(interact as any).default = interact\n","// eslint-disable-next-line import/no-extraneous-dependencies\nimport interact from '@interactjs/interactjs/index'\n\nexport default interact\n\nif (typeof module === 'object' && !!module) {\n  try { module.exports = interact }\n  catch {}\n}\n\n(interact as any).default = interact\n","\nreturn _$index_86;\n\n});\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar cookies = require('./../helpers/cookies');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    if (\n      (utils.isBlob(requestData) || utils.isFile(requestData)) &&\n      requestData.type\n    ) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = unescape(encodeURIComponent(config.auth.password)) || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"react\")):\"function\"==typeof define&&define.amd?define(\"reactLoadingMask\",[\"react\"],t):\"object\"==typeof exports?exports.reactLoadingMask=t(require(\"react\")):e.reactLoadingMask=t(e.react)}(\"undefined\"!=typeof self?self:this,(function(e){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=1)}([function(t,n){t.exports=e},function(e,t,n){\"use strict\";n.r(t),n.d(t,\"default\",(function(){return b}));var r=n(0),o=n.n(r);function c(e){return(c=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function i(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function a(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function u(e,t){return(u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function f(e){var t=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=s(e);if(t){var o=s(this).constructor;n=Reflect.construct(r,arguments,o)}else n=r.apply(this,arguments);return l(this,n)}}function l(e,t){return!t||\"object\"!==c(t)&&\"function\"!=typeof t?function(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}(e):t}function s(e){return(s=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var p,y,d,b=function(e){!function(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&u(e,t)}(l,e);var t,n,r,c=f(l);function l(){return i(this,l),c.apply(this,arguments)}return t=l,(n=[{key:\"render\",value:function(){var e=this.props,t=e.loading,n=e.prefixCls,r=e.indicator,c=this.props.loadingText,i=t?n:\"\".concat(n,\"-hide\"),a=this.props,u=a.className,f=a.style,l=\"\".concat(u,\" \").concat(i);return o.a.createElement(\"div\",{className:l,style:f},o.a.createElement(\"div\",{className:\"\".concat(n,\"-mask\")},o.a.createElement(\"div\",{className:\"\".concat(n,\"-icon\")},r),o.a.createElement(\"div\",{className:\"\".concat(n,\"-text\")},c)),o.a.createElement(\"div\",{className:\"\".concat(n,\"-content\")},this.props.children))}}])&&a(t.prototype,n),r&&a(t,r),l}(o.a.PureComponent);p=b,y=\"defaultProps\",d={loading:!1,text:\"\",prefixCls:\"rc-loading\",className:\"\",style:{},indicator:o.a.createElement(\"span\",{className:\"rc-loading-icon-default\"})},y in p?Object.defineProperty(p,y,{value:d,enumerable:!0,configurable:!0,writable:!0}):p[y]=d}])}));","var api = require(\"!../../style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../../css-loader/dist/cjs.js!./react-loadingmask.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};","\"use strict\";\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce = typeof __webpack_nonce__ !== 'undefined' ? __webpack_nonce__ : null;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \"@keyframes spin {\\r\\n  from {\\r\\n    transform: rotate(0deg);\\r\\n  }\\r\\n  to {\\r\\n    transform: rotate(359deg);\\r\\n  }\\r\\n}\\r\\n\\r\\n@keyframes fade-in-move-down {\\r\\n  0% {\\r\\n    left: 0;\\r\\n  }\\r\\n  100% {\\r\\n    left: 100%;\\r\\n  }\\r\\n}\\r\\n\\r\\n.rc-loading,\\r\\n.rc-loading-hide {\\r\\n  position: relative;\\r\\n}\\r\\n\\r\\n.rc-loading::before {\\r\\n  content: \\\"\\\";\\r\\n  display: table;\\r\\n}\\r\\n\\r\\n.rc-loading::after {\\r\\n  content: \\\"\\\";\\r\\n  position: absolute;\\r\\n  top: 0;\\r\\n  right: 0;\\r\\n  bottom: 0;\\r\\n  left: 0;\\r\\n  background-color: #000;\\r\\n  opacity: 0.5;\\r\\n  height: 100%;\\r\\n  width: 100%;\\r\\n  z-index: 1;\\r\\n}\\r\\n\\r\\n.rc-loading-mask {\\r\\n  position: absolute;\\r\\n  height: 100%;\\r\\n  width: 100%;\\r\\n  text-align: center;\\r\\n  z-index: 0;\\r\\n  overflow: hidden;\\r\\n}\\r\\n.rc-loading .rc-loading-content {\\r\\n  opacity: 0.5;\\r\\n}\\r\\n\\r\\n.rc-loading-hide .rc-loading-mask {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n.rc-loading .rc-loading-mask {\\r\\n  z-index: 2;\\r\\n}\\r\\n\\r\\n.rc-loading .rc-loading-icon {\\r\\n  position: absolute;\\r\\n  top: 50%;\\r\\n  z-index: 2;\\r\\n  width: 100%;\\r\\n  cursor: default;\\r\\n  margin-top: -12px;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.rc-loading-icon-default {\\r\\n  border-width: 3px;\\r\\n  border-style: solid;\\r\\n  border-color: transparent #fff #fff #fff;\\r\\n  border-radius: 50%;\\r\\n  width: 24px;\\r\\n  height: 24px;\\r\\n  animation: 3s linear 0s normal none infinite running spin;\\r\\n  filter: drop-shadow(0 0 2 rgba(0, 0, 0, 0.33));\\r\\n  display: inline-block;\\r\\n}\\r\\n\\r\\n.rc-loading .rc-loading-text {\\r\\n  position: absolute;\\r\\n  width: 100%;\\r\\n  color: #fff;\\r\\n  top: 50%;\\r\\n  padding-top: 24px;\\r\\n  font-size: 14px;\\r\\n  opacity: 1;\\r\\n}\\r\\n\\r\\n.rc-loading-spin {\\r\\n  animation: spin 2s infinite linear;\\r\\n}\\r\\n\\r\\n.rc-loading-move-right {\\r\\n  position: absolute;\\r\\n  animation: fade-in-move-down 5s linear infinite;\\r\\n}\\r\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","export default __webpack_public_path__ + \"styles.css\";","export class Point {\n\n\tconstructor(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tequals(pt) {\n\t\treturn pt.x === this.x && pt.y === this.y;\n\t}\n\tnorm() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t}\n\n\tadd(pt) {\n\t\treturn new Point(this.x + pt.x, this.y + pt.y);\n\t}\n\n\tsub(pt) {\n\t\treturn new Point(this.x - pt.x, this.y - pt.y);\n\t}\n\n\tmult(scalar) {\n\t\treturn new Point(this.x * scalar, this.y * scalar);\n\t}\n\n\tdiv(scalar) {\n\t\treturn new Point(this.x / scalar, this.y / scalar);\n\t}\n\n\tdistTo(pt) {\n\t\tconst dx = this.x - pt.x;\n\t\tconst dy = this.y - pt.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tangle(pt) {\n\t\tconst dx = this.x - pt.x;\n\t\tconst dy = this.y - pt.y;\n\t\treturn Math.atan2(dy, dx);\n\t}\n\n\ttoString(){\n\t\treturn `Point(x:${this.x}, y:${this.y})`\n\t}\n}\n\nexport function middlePoint(pt1, pt2) {\n\treturn new Point((pt1.x + pt2.x) / 2, (pt1.y + pt2.y) / 2);\n}\n\nexport function pointAtDistance(p0, p1, dist) {\n\tif (p1.equals(p0)) {\n\t\tthrow new Error('Input points cannot be equal');\n\t}\n\tconst ratio = dist / p1.sub(p0).norm();\n\treturn p0.add(p1.sub(p0).mult(ratio));\n}\n\nexport function pointsAtDistanceNorm(p1, p2, d, p0 = null) {\n\tif (p1.equals(p2)) {\n\t\tthrow new Error('Input points cannot be equal');\n\t}\n\n\tif (p0 == null) {\n\t\tp0 = p1.add(p2).div(2.0);\n\t}\n\tconst pa = new Point(0, 0);\n\tconst pb = new Point(0, 0); // Points at distance d from the normal line passing from the center of p1 and p2 (i.e. p0)\n\tif (p1.x === p2.x) {\n\t\tpa.y = pb.y = p0.y;\n\t\tpa.x -= d;\n\t\tpb.x += d;\n\t} else if (p1.y === p2.y) {\n\t\tpa.x = pb.x = p0.x;\n\t\tpa.y -= d;\n\t\tpb.y += d;\n\t} else {\n\t\tconst ddx = p2.x - p1.x;\n\t\tconst ddy = p2.y - p1.y;\n\t\tconst m = -ddx / ddy; // m' = -1/m\n\t\tlet dx = d / Math.sqrt(1 + m * m);\n\t\tif (ddy < 0) {\n\t\t\tdx = -dx;\n\t\t}\n\t\tpa.x = p0.x + dx;\n\t\tpb.x = p0.x - dx;\n\t\tpa.y = m * (pa.x - p0.x) + p0.y;\n\t\tpb.y = m * (pb.x - p0.x) + p0.y;\n\t}\n\treturn [pa, pb];\n}\n\nexport function translateSegmentParallel(p1, p2, d) {\n\tconst p1s = pointsAtDistanceNorm(p1, p2, d, p1);\n\tconst p2s = pointsAtDistanceNorm(p1, p2, d, p2);\n\treturn [p1s[0], p2s[0]];\n}\n\nexport function toMillimeters(v, units) {\n\tswitch (units) {\n\t\tcase 'mm':\n\t\t\treturn v;\n\t\tcase 'inch':\n\t\t\treturn v * 25.4;\n\t\tcase 'cm':\n\t\t\treturn v * 10.0;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown input units when creating the photo standard definition');\n\t}\n}\n\nexport function rotatedRectangle(center, width, height, angle) {\n\tconst w2 = width / 2;\n\tconst h2 = height / 2;\n\tconst cosAngle = Math.cos(angle);\n\tconst sinAngle = Math.sin(angle);\n\tconst corners = [];\n\tfor (const p of [[-w2, -h2], [-w2, h2], [w2, h2], [w2, -h2]]) {\n\t\tconst x = center.x + p[0] * cosAngle - p[1] * sinAngle;\n\t\tconst y = center.y + p[0] * sinAngle + p[1] * cosAngle;\n\t\tcorners.push(new Point(x, y));\n\t}\n\treturn corners;\n}","import { Point, toMillimeters, middlePoint, pointAtDistance, rotatedRectangle } from './point';\n\nexport class PhotoDimensions {\n  pictureWidth;\n  pictureHeight;\n  units;\n  faceHeight;\n  crownTop;\n  dpi;\n}\n\nexport function getCroppingCenter(p, crownPoint, chinPoint) {\n  if (!(p.crownTop > 0)) {\n    // Estimate the center of the picture to be the median point between the crown point and the chin point\n    return middlePoint(crownPoint, chinPoint);\n  }\n  const crownToBottom = p.pictureHeight - p.crownTop;\n  const crownToCenter = crownToBottom - p.pictureHeight / 2;\n  const mmToPixRatio = crownPoint.sub(chinPoint).norm() / p.faceHeight;\n  const crownToCenterPix = mmToPixRatio * crownToCenter;\n  return pointAtDistance(crownPoint, chinPoint, crownToCenterPix);\n}\n\nexport function getCroppingRectangle(p, crownPoint, chinPoint) {\n  const centerPic = getCroppingCenter(p, crownPoint, chinPoint);\n  const faceHeightPix = crownPoint.distTo(chinPoint);\n  const normal = crownPoint.angle(chinPoint);\n  const scale = faceHeightPix / p.faceHeight;\n  const cropHeightPix = p.pictureHeight * scale;\n  const cropWidthPix = p.pictureWidth * scale;\n\n  return rotatedRectangle(centerPic, cropWidthPix, cropHeightPix, normal);\n}\n","export const Events = {\n\tUPDATE_LANDMARK: 'update_landmark',\n\tLOADED_IMAGE: 'loaded_image',\n};","import { Component, h } from 'preact';\nimport interact from 'interactjs';\nimport { middlePoint, Point, pointsAtDistanceNorm, rotatedRectangle } from '../../model/point';\nimport { getCroppingCenter, PhotoDimensions } from '../../model/photodimensions';\nimport EventEmitter from 'eventemitter3';\nimport { Events } from '../../shared/event-emitter/events';\nimport axios from 'axios';\n\nclass Editor extends Component {\n\n\tconstructor() {\n\t\tsuper();\n\t\t// size of circle markers\n\t\tthis._crownChinMarkSize = 16;\n\t\tthis.state = {\n\t\t\tcrownPosition: {},\n\t\t\tchinPosition: {},\n\t\t\tlandmarkVisibility: true,\n\t\t\timage: null\n\t\t};\n\t}\n\n\tcomponentDidUpdate(prevProps, prevState, snapshot) {\n\t\tconsole.log(prevProps);\n\t\tconsole.log(this.props);\n\t\tif (this.props.imageUrl && prevProps.imageUrl !== this.props.imageUrl) {\n\t\t\tconsole.log('loadAndRenderImage');\n\t\t\tthis.loadAndRenderImage(this.props.imageUrl);\n\t\t}\n\n\t}\n\n\tcomponentDidMount() {\n\t\tthis._imgElmt = document.querySelector('#inputPhoto');\n\t\tthis._viewPortElmt = document.querySelector('#viewport');\n\t\tthis._crownMarkElmt = document.querySelector('#crownMark');\n\t\tthis._chinMarkElmt = document.querySelector('#chinMark');\n\t\tconst lmSize = '' + this._crownChinMarkSize + 'px';\n\t\tthis._crownMarkElmt.style.width = lmSize;\n\t\tthis._crownMarkElmt.style.height = lmSize;\n\t\tthis._chinMarkElmt.style.width = lmSize;\n\t\tthis._chinMarkElmt.style.height = lmSize;\n\n\t\tthis._middleLine = document.querySelector('#middleLine');\n\t\tthis._crownLine = document.querySelector('#crownLine');\n\t\tthis._chinLine = document.querySelector('#chinLine');\n\n\t\tthis._faceEllipse = document.querySelector('#faceEllipse');\n\t\tthis._cropArea = document.querySelector('#cropArea');\n\t\tthis._imageArea = document.querySelector('#imageArea');\n\n\t\tthis._cropRect = document.querySelector('#cropRect');\n\n\t\tlet standard = {\n\t\t\t'id': 'ua_visa_photo',\n\t\t\t'text': 'Ukraine Visa 3x4 cm (30x40 mm)',\n\t\t\t'country': 'Ukraine',\n\t\t\t'docType': 'Visa',\n\t\t\t'dimensions': {\n\t\t\t\t'pictureWidth': 30.0,\n\t\t\t\t'pictureHeight': 40.0,\n\t\t\t\t'units': 'mm',\n\t\t\t\t'dpi': 600.0,\n\t\t\t\t'faceHeight': 31.0,\n\t\t\t\t'crownTop': 2.5\n\t\t\t},\n\t\t\t'backgroundColor': '#eeeeee',\n\t\t\t'printable': true,\n\t\t\t'officialLinks': [\n\t\t\t\t'http://mfa.gov.ua/ua/consular-affairs/entering-ukraine/visa-mfa-branches'\n\t\t\t],\n\t\t\t'comments': ''\n\t\t};\n\n\t\tthis._photoDimensions = standard.dimensions;\n\n\t\tinteract('.landmark').draggable({\n\t\t\t// enable inertial throwing\n\t\t\tinertia: true,\n\t\t\t// keep the element within the area of it's parent\n\t\t\tmodifiers: [\n\t\t\t\tinteract.modifiers.restrictRect({\n\t\t\t\t\trestriction: 'parent',\n\t\t\t\t\tendOnly: true,\n\t\t\t\t\telementRect: { top: 0.5, left: 0.5, bottom: 1, right: 1 }\n\t\t\t\t})\n\t\t\t],\n\n\t\t\t// call this function on every dragmove event\n\t\t\tonmove: event => {\n\t\t\t\tconst target = event.target;\n\t\t\t\t// keep the dragged position in the x/y attributes\n\t\t\t\tconst x = (parseFloat(target.getAttribute('x')) || 0) + event.dx;\n\t\t\t\tconst y = (parseFloat(target.getAttribute('y')) || 0) + event.dy;\n\t\t\t\t// translate the element\n\t\t\t\tthis.translateElement(target, new Point(x, y));\n\t\t\t\tthis.renderSvgFrame();\n\t\t\t},\n\t\t\t// call this function on every dragend event\n\t\t\tonend: event => {\n\t\t\t\tthis.updateLandMarks();\n\t\t\t}\n\t\t});\n\t}\n\n\ttoDataURL = url => fetch(url)\n\t\t.then(response => response.blob())\n\t\t.then(blob => new Promise((resolve, reject) => {\n\t\t\tconst reader = new FileReader();\n\t\t\treader.onloadend = () => resolve(reader.result);\n\t\t\treader.onerror = reject;\n\t\t\treader.readAsDataURL(blob);\n\t\t}));\n\n\tloadAndRenderImage(url) {\n\t\tthis.toDataURL(url)\n\t\t\t.then(data => {\n\t\t\t\tthis.setState({\n\t\t\t\t\timage: data\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\tonLoadImage() {\n\t\tthis._imageWidth = this._imgElmt.naturalWidth;\n\t\tthis._imageHeight = this._imgElmt.naturalHeight;\n\t\tif (this._imageWidth > 100 && this._imageHeight > 100) {\n\t\t\tthis._imgElmt.style.visibility = 'visible';\n\t\t\tthis.calculateViewPort();\n\t\t\tthis.zoomFit();\n\t\t\tthis.renderImage();\n\t\t\tthis.setLandMarks(new Point(161, 50), new Point(150, 150));\n\t\t}\n\t\tthis.props.emitter.emit(Events.LOADED_IMAGE, {\n\t\t\tviewPortWidth: this._viewPortWidth,\n\t\t\tviewPortHeight: this._viewPortHeight\n\t\t});\n\t\tthis.scaledImageWidth = this._imageArea.getAttribute('width');\n\t\tthis.scaledImageHeight = this._imageArea.getAttribute('height');\n\t\tconsole.log(this.scaledImageWidth);\n\t}\n\n\tcalculateViewPort() {\n\t\tif (!this._viewPortElmt) {\n\t\t\treturn;\n\t\t}\n\t\tthis._viewPortWidth = this._viewPortElmt.clientWidth;\n\t\tthis._viewPortHeight = this._viewPortElmt.clientHeight;\n\t}\n\n\tzoomFit() {\n\t\tif (!(this._imageWidth > 0) || !(this._imageHeight > 0)) {\n\t\t\treturn;\n\t\t}\n\t\tconst xRatio = this._viewPortWidth / this._imageWidth;\n\t\tconst yRatio = this._viewPortHeight / this._imageHeight;\n\t\tthis._ratio = xRatio < yRatio ? xRatio : yRatio;\n\t\tthis._xLeft = this._viewPortWidth / 2 - (this._ratio * this._imageWidth) / 2;\n\t\tthis._yTop = this._viewPortHeight / 2 - (this._ratio * this._imageHeight) / 2;\n\t}\n\n\trenderImage() {\n\t\tconst xw = this._imageWidth * this._ratio;\n\t\tconst yh = this._imageHeight * this._ratio;\n\t\tthis._imgElmt.width = xw;\n\t\tthis._imgElmt.height = yh;\n\t\tthis.translateElement(this._imgElmt, new Point(this._xLeft, this._yTop));\n\t}\n\n\tsetLandMarks(crownPoint, chinPoint) {\n\t\tthis.crownPoint = crownPoint;\n\t\tthis.chinPoint = chinPoint;\n\t\tthis.renderLandMarks();\n\t}\n\n\tupdateLandMarks() {\n\t\tthis.crownPoint = this.screenToPixel(this._crownMarkElmt, true);\n\t\tthis.chinPoint = this.screenToPixel(this._chinMarkElmt, true);\n\n\t\tthis.setState({\n\t\t\tcrownPosition: this.crownPoint,\n\t\t\tchinPosition: this.chinPoint\n\t\t});\n\n\t\tlet height = parseInt(this._cropArea.getAttribute('height'));\n\t\tlet width = parseInt(this._cropArea.getAttribute('width'));\n\n\t\tlet imageHeight = parseInt(this._imgElmt.getAttribute('height'));\n\t\tlet imageWidth = parseInt(this._imgElmt.getAttribute('width'));\n\t\t//console.log(imageWidth, imageHeight);\n\t\tlet crownPoint = {\n\t\t\tx: (this.crownPoint.x * this._ratio) / imageWidth * 100,\n\t\t\ty: (this.crownPoint.y * this._ratio) / imageHeight * 100\n\t\t};\n\t\tlet chinPoint = {\n\t\t\tx: (this.chinPoint.x * this._ratio) / imageWidth * 100,\n\t\t\ty: (this.chinPoint.y * this._ratio) / imageHeight * 100\n\t\t};\n\t\tconsole.log(`x:${crownPoint.x}%, y:${crownPoint.y}%`);\n\t\tthis.props.emitter.emit(Events.UPDATE_LANDMARK, {\n\t\t\tcrownPosition: crownPoint,\n\t\t\tchinPosition: chinPoint,\n\t\t});\n\n\t}\n\n\trenderLandMarks() {\n\t\tif (\n\t\t\tthis.crownPoint &&\n\t\t\tthis.crownPoint.x &&\n\t\t\tthis.crownPoint.y &&\n\t\t\tthis.chinPoint &&\n\t\t\tthis.chinPoint.x &&\n\t\t\tthis.chinPoint.y &&\n\t\t\tthis._imageWidth > 100 &&\n\t\t\tthis._imageHeight > 100\n\t\t) {\n\t\t\tconst p1 = this.pixelToScreen(this.crownPoint);\n\t\t\tconst p2 = this.pixelToScreen(this.chinPoint);\n\t\t\tthis.translateElement(this._crownMarkElmt, p1);\n\t\t\tthis.translateElement(this._chinMarkElmt, p2);\n\t\t\tthis.renderSvgFrame();\n\t\t\tthis.landmarkVisibility = 'visible';\n\t\t}\n\t\telse {\n\t\t\tthis.landmarkVisibility = 'hidden';\n\t\t}\n\t}\n\n\tpixelToScreen(pt) {\n\t\treturn new Point(\n\t\t\tthis._xLeft + pt.x /** this._ratio*/ - this._crownChinMarkSize / 2,\n\t\t\tthis._yTop + pt.y /** this._ratio*/ - this._crownChinMarkSize / 2\n\t\t);\n\t}\n\n\tscreenToPixel(pt, round = false) {\n\t\tif (pt.x === undefined || pt.y === undefined) {\n\t\t\tpt = this.getMarkScreenCenter(pt);\n\t\t}\n\t\tconst xPrime = (pt.x - this._xLeft) / this._ratio;\n\t\tconst yPrime = (pt.y - this._yTop) / this._ratio;\n\t\tif (round) {\n\t\t\treturn new Point(Math.round(xPrime), Math.round(yPrime));\n\t\t}\n\t\treturn new Point(xPrime, yPrime);\n\t}\n\n\tgetMarkScreenCenter(elmt) {\n\t\tconst x = parseFloat(elmt.getAttribute('x')) + (this._crownChinMarkSize) / 2.0;\n\t\tconst y = parseFloat(elmt.getAttribute('y')) + (this._crownChinMarkSize) / 2.0;\n\t\treturn new Point(x, y);\n\t}\n\n\ttranslateElement(elmt, pt) {\n\t\t// Translate the element position\n\t\telmt.style.transform = elmt.style.webkitTransform = `translate(${pt.x}px, ${pt.y}px)`;\n\t\t// Store it in attached properties\n\t\telmt.setAttribute('x', pt.x);\n\t\telmt.setAttribute('y', pt.y);\n\t}\n\n\trenderSvgFrame() {\n\t\tconst p1 = this.getMarkScreenCenter(this._crownMarkElmt);\n\t\tconst p2 = this.getMarkScreenCenter(this._chinMarkElmt);\n\n\t\t// Render middle line\n\t\tthis._renderSegment(this._middleLine, p1, p2);\n\n\t\tconst faceHeight = p1.distTo(p2);\n\t\tconst crownSegment = pointsAtDistanceNorm(p1, p2, faceHeight * 0.5, p1);\n\t\tthis._renderSegment(this._crownLine, crownSegment[0], crownSegment[1]);\n\n\t\tconst chinSegment = pointsAtDistanceNorm(p1, p2, faceHeight * 0.5, p2);\n\t\tthis._renderSegment(this._chinLine, chinSegment[0], chinSegment[1]);\n\n\t\t// Render face ellipse\n\t\tconst ra = faceHeight / 2;\n\t\tconst rb = 0.68 * ra;\n\t\tconst pc = middlePoint(p1, p2);\n\t\tconst angleRad = p2.angle(p1);\n\t\tconst angleDeg = (angleRad * 180) / Math.PI;\n\t\tthis._faceEllipse.setAttribute('rx', ra);\n\t\tthis._faceEllipse.setAttribute('ry', rb);\n\t\tthis._faceEllipse.setAttribute('cx', pc.x);\n\t\tthis._faceEllipse.setAttribute('cy', pc.y);\n\t\tthis._faceEllipse.setAttribute('transform', `rotate(${angleDeg}, ${pc.x}, ${pc.y})`);\n\n\t\t// Render photo cropping rectangle\n\t\tif (!this._photoDimensions) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst cropCenter = getCroppingCenter(this._photoDimensions, p1, p2);\n\t\tconst scale = faceHeight / this._photoDimensions.faceHeight;\n\t\tconst dx = this._photoDimensions.pictureHeight * scale;\n\t\tconst dy = this._photoDimensions.pictureWidth * scale;\n\n\t\tconst svgElmt = this._imageArea;\n\t\tsvgElmt.setAttribute('x', this._xLeft);\n\t\tsvgElmt.setAttribute('y', this._yTop);\n\t\tsvgElmt.setAttribute('width', this._imageWidth * this._ratio);\n\t\tsvgElmt.setAttribute('height', this._imageHeight * this._ratio);\n\n\t\tthis._setRotatedRect(this._cropArea, cropCenter, dx, dy, angleDeg);\n\t\tthis._setRotatedRect(this._cropRect, cropCenter, dx, dy, angleDeg);\n\t\tconst points = rotatedRectangle(cropCenter, dx, dy, angleRad);\n\t\tthis.frameCoords = points;\n\t\tconst invalidCrop = points.some(pt => {\n\t\t\tconst ptPix = this.screenToPixel(pt);\n\t\t\treturn ptPix.x < 0 || ptPix.x > this._imageWidth || ptPix.y < 0 || ptPix.y > this._imageHeight;\n\t\t});\n\t\tthis._cropRect.setAttribute('stroke', invalidCrop ? 'red' : 'green');\n\t}\n\n\t_setRotatedRect(svgElmt, center, w, h, angle) {\n\t\tsvgElmt.setAttribute('x', center.x - w / 2);\n\t\tsvgElmt.setAttribute('y', center.y - h / 2);\n\t\tsvgElmt.setAttribute('width', w);\n\t\tsvgElmt.setAttribute('height', h);\n\t\tsvgElmt.setAttribute('transform', `rotate(${angle}, ${center.x}, ${center.y})`);\n\t}\n\n\t_renderSegment(svdElmt, p1, p2) {\n\t\tsvdElmt.setAttribute('x1', p1.x);\n\t\tsvdElmt.setAttribute('y1', p1.y);\n\t\tsvdElmt.setAttribute('x2', p2.x);\n\t\tsvdElmt.setAttribute('y2', p2.y);\n\t}\n\n\timageLoadFailed() {\n\t}\n\n\trender(props, state, context) {\n\t\treturn <div id=\"viewport\">\n\t\t\t<img\n\t\t\t\tid=\"inputPhoto\"\n\t\t\t\talt=\"Input Image\"\n\t\t\t\ttitle=\"Input picture\"\n\t\t\t\tsrc={this.state.image}\n\t\t\t\tonLoad={this.onLoadImage.bind(this)}\n\t\t\t\tonError={this.imageLoadFailed.bind(this)}\n\n\t\t\t/>\n\t\t\t<svg className=\"box\" style={{ visibility: this.state.landmarkVisibility ? 'visible' : 'hidden' }}\n\t\t\t\t pointer-events=\"none\">\n\t\t\t\t<image class=\"inputPhoto\" xlink:href={this.state.image} x=\"0\" y=\"0\" height=\"0\" width=\"0\"/>\n\t\t\t\t<defs>\n\t\t\t\t\t<mask id=\"mask\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">\n\t\t\t\t\t\t<rect id=\"imageArea\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"#ffffff\"/>\n\t\t\t\t\t\t<rect id=\"cropArea\" x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"#000\"/>\n\t\t\t\t\t</mask>\n\t\t\t\t</defs>\n\t\t\t\t<rect x=\"0\" y=\"0\" width=\"1000\" height=\"1000\" fill-opacity=\"0.4\" mask=\"url(#mask)\"/>\n\t\t\t\t<rect id=\"cropRect\" x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"none\"/>\n\t\t\t\t<line id=\"heightLine\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"0\" className=\"dimension-line\"/>\n\t\t\t\t<line id=\"widthLine\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"0\" className=\"dimension-line\"/>\n\t\t\t\t<line id=\"middleLine\" x1=\"0\" y1=\"0\" x2=\"200\" y2=\"200\" className=\"annotation\"/>\n\t\t\t\t<line id=\"crownLine\" x1=\"0\" y1=\"0\" x2=\"200\" y2=\"200\" className=\"annotation\"/>\n\t\t\t\t<line id=\"chinLine\" x1=\"0\" y1=\"0\" x2=\"200\" y2=\"200\" className=\"annotation\"/>\n\t\t\t\t<ellipse id=\"faceEllipse\" cx=\"100\" cy=\"50\" rx=\"100\" ry=\"50\" fill=\"none\" className=\"annotation\"/>\n\n\t\t\t</svg>\n\t\t\t<div className=\"landmark\" id=\"crownMark\"\n\t\t\t\t style={{ visibility: this.state.landmarkVisibility ? 'visible' : 'hidden' }}/>\n\t\t\t<div className=\"landmark\" id=\"chinMark\"\n\t\t\t\t style={{ visibility: this.state.landmarkVisibility ? 'visible' : 'hidden' }}/>\n\t\t</div>;\n\t}\n}\n\nexport default Editor;\n","import { Component, h } from 'preact';\nimport { Events } from '../../shared/event-emitter/events';\nimport axios from 'axios';\nimport LoadingMask from \"react-loadingmask\";\n\nclass Preview extends Component{\n\tconstructor(){\n\t\tsuper();\n\t\tthis.image = new Image();\n\t\tthis.state = {\n\t\t\tpreview: null,\n\t\t\tcropArea: {\n\t\t\t\tx:50, y:50, w:50, h:50\n\t\t\t}\n\t\t}\n\t}\n\t emitted(dATA) {\n\t\tconsole.log(dATA); // true\n\t}\n\n\n\tcomponentDidMount() {\n\t\tthis.props.emitter.on(Events.LOADED_IMAGE, (data) => {\n\t\t\tconsole.log(data);\n\t\t});\n\t\tthis.props.emitter.on(Events.UPDATE_LANDMARK, (data) => {\n\t\t\tconsole.log(data);\n\t\t\tthis.setState({\n\t\t\t\tcropArea: {\n\t\t\t\t\tx:data.crownPosition.x,\n\t\t\t\t\ty:data.crownPosition.y,\n\t\t\t\t\tw:data.chinPosition.x,\n\t\t\t\t\th:data.chinPosition.y\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t\tthis.canvas = document.querySelector(\"#canvasPreview\");\n\t\tthis.ctx = this.canvas.getContext('2d');\n\t\tthis.canvas.style.width = '300px';\n\t\tthis.canvas.style.height = '400px';\n\t\tthis.image.src = \"https://image.shutterstock.com/image-photo/beauty-woman-face-portrait-beautiful-260nw-323982494.jpg\";\n\t\tthis.image.onload = () => {\n\t\t\tthis.ctx.drawImage(this.image,\n\t\t\t\tthis.state.cropArea.x, this.state.cropArea.y,   // Start at 70/20 pixels from the left and the top of the image (crop),\n\t\t\t\t50, this.state.cropArea.h,   // \"Get\" a `50 * 50` (w * h) area from the source image (crop),\n\t\t\t\t0, 0,     // Place the result at 0, 0 in the canvas,\n\t\t\t\t400, 300); // With as width / height: 100 * 100 (scale)\n\t\t}\n\n\t\t//https://image.shutterstock.com/image-photo/beauty-woman-face-portrait-beautiful-260nw-323982494.jpg\n\n\n\n\t}\n\n\n\tcomponentDidUpdate(prevProps, prevState, nextContext) {\n\t\tconsole.log();\n\n\t\tif (this.props.imageUrl && prevProps.imageUrl !== this.props.imageUrl) {\n\t\t\tconsole.log(this.props.imageUrl)\n\t\t\taxios.post('http://localhost:5000/api/render-photo', {\n\t\t\t\turl: this.props.imageUrl,\n\t\t\t\tsize: this.props.previewSize\n\t\t\t})\n\t\t\t\t.then((response) => {\n\t\t\t\t\t// handle success\n\t\t\t\t\tconsole.log(response.data);\n\t\t\t\t\tthis.setState({\n\t\t\t\t\t\tpreview: 'data:image/png;base64, ' + response.data\n\t\t\t\t\t});\n\t\t\t\t}).catch(error => {\n\t\t\t\t// handle error\n\t\t\t\tconsole.log(error);\n\t\t\t});\n\t\t}\n\t}\n\n\trender(props, state, context) {\n\t\treturn (\n\t\t\t<LoadingMask loading={this.state.preview == null} text={\"loading...\"}>\n\t\t\t\t<div style={{width:'200px', height:'200px'}}>\n\t\t\t\t\t<canvas id=\"canvasPreview\" style={{display: \"none\"}}></canvas>\n\t\t\t\t\t<svg width=\"3cm\" height=\"4cm\" version=\"1.1\">\n\t\t\t\t\t\t<image xlink:href={this.state.preview} x=\"0\" y=\"0\" height=\"100%\" width=\"100%\"></image>\n\t\t\t\t\t</svg>\n\t\t\t\t</div>\n\t\t\t</LoadingMask>\n\t\t)\n\n\t}\n}\n\nexport default Preview","import { h, Component } from 'preact';\nimport EventEmitter from 'eventemitter3';\nimport Editor from './editor';\nimport Preview from './preview';\nimport React from 'preact/compat';\n\n\nexport default class App extends Component {\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.state = {\n\t\t\tview: 'editor'\n\t\t};\n\t}\n\n\trender(props, state, context) {\n\t\tthis.emitter = new EventEmitter();\n\n\t\treturn (\n\t\t\t<div class=\"\" style={{display:\"flex\"}}>\n\t\t\t\t<Editor emitter={this.emitter} imageUrl={this.state.imageUrl}/>\n\n\t\t\t\t<Preview emitter={this.emitter} imageUrl={this.state.imageUrl} previewSize={this.props.options.preview.size}/>\n\n\t\t\t\t<button style={{ 'margin': '0 auto' }} onClick={this.switchView.bind(this)}>\n\t\t\t\t\t{this.state.view === 'editor' ? 'Preview' : 'Edit'}\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t);\n\t}\n\n\tswitchView = () => {\n\t\tthis.setState({\n\t\t\tview: this.state.view === 'editor' ? 'preview' : 'editor',\n\t\t\timageUrl: this.state.imageUrl\n\t\t});\n\t};\n\n\tsetImageUrl = url => {\n\t\tthis.setState({\n\t\t\timageUrl: url\n\t\t});\n\t};\n}\n","import './style/styles.scss'\nimport \"react-loadingmask/dist/react-loadingmask.css\";\n\nimport {h, Component, render, createRef} from 'preact';\nimport App from './components/app'\nimport React from 'preact/compat';\n\nclass PhotoPassport extends Component{\n\tconstructor(options){\n\t\tsuper();\n\t\tthis.child = createRef();\n\t\tlet defaults = {\n\t\t\tpreview:{\n\t\t\t\tsize: 250\n\t\t\t}\n\t\t}\n\t\t//options = {...options, defaults};\n\t\toptions = Object.assign({}, defaults, options);\n\t\tconsole.log(options)\n\t\tlet container = document.getElementById(options.container) || document.body;\n\t\t//container.addEventListener('contextmenu', event => event.preventDefault());\n\t\trender(\n\t\t\t<App ref={this.child} options={options}/>, container\n\t\t)\n\t}\n\n\tsetImage = (imageUrl) => {\n\t\tthis.child.current.setImageUrl(imageUrl);\n\n\t}\n\n}\nexport default PhotoPassport;\n"],"sourceRoot":""}